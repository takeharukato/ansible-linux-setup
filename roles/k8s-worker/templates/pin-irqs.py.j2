#!/usr/bin/env python3
#  -*- coding:utf-8 mode:python -*-
# This file is generated by ansible.
# {# 日付の取得 #}
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}

#
# 割込みを片寄せするpython スクリプト
# Copyright 2025 Takeharu KATO
# This script was created with the assistance of ChatGPT.
# ChatGPTの補助により本スクリプトを作成.
#

from typing import Dict

import argparse
import os
import re
import sys
from pathlib import Path
from glob import glob

INTERRUPTS = "/proc/interrupts" # 割込み一覧
PROC_IRQ_DIR = "/proc/irq"      # 割込み操作/procファイル
ONLINE_CPUS="/sys/devices/system/cpu/online"
IRQ_DEFAULT_SMP_AFFINITY="/proc/irq/default_smp_affinity"

def parse_interrupts() -> Dict[int, str]:
    """/proc/interrupts を読み, 使用中の IRQ 番号 -> /proc/interruptsの対応する行を返す

    Returns:
        Dict[int, str]: IRQ番号から/proc/interruptsの対応する行への辞書
    """
    active: Dict[int, str] = {}
    try:
        with open(INTERRUPTS, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                m = re.match(r"^\s*(\d+):", line)
                if not m:
                    continue  # NMI, LOC などの非数値行は無視
                irq = int(m.group(1))
                active[irq] = line.rstrip("\n")
    except Exception as e:
        print(f"[ERROR] failed to read {INTERRUPTS}: {e}", file=sys.stderr)
        sys.exit(3)
    return active

def parse_cpulist(cpulist: str) -> set[int]:
    """CPUリスト表記(例:0-1など)をrangeの集合に変換

    Args:
        cpulist (str): cpuリスト表記

    Raises:
        ValueError: CPUリストが空

    Returns:
        set[int]: CPUリストの各範囲をrangeで格納した集合
    """
    s: set[int] = set()
    for part in cpulist.split(","):
        # CPUリストを','で分割
        part = part.strip() # 末尾の空白を削除
        if not part:
            continue # 空の場合
        if "-" in part: # 範囲指定'-'がある場合
            a, b = part.split("-", 1) # -の前後で分離
            a, b = int(a), int(b) # 各値を取得
            if a > b: # 開始CPU番号の方が大きい場合
                a, b = b, a # 順序を入れ替える
            s.update(range(a, b + 1)) # 集合に範囲を格納
        else:
            s.add(int(part))
    if not s:
        raise ValueError("Empty CPU list")
    return s

def read_online_cpus() -> set[int]:
    """オンラインCPUの集合を得る
    Returns:
        set[int]: オンラインCPUの集合
    """
    p = Path(ONLINE_CPUS)
    if not p.exists():
        return set()
    txt = p.read_text().strip()
    return parse_cpulist(txt)

def cpuset_to_hexmask(cpus: set[int]) -> str:
    """CPU集合を16進数のマスク値に変換する
    例: {0,1,4} -> "13" (0b10011)
    先頭の '0x' は付けない ( /proc は16進文字列を期待するため )

    Args:
        cpus (set[int]): CPU集合

    Raises:
        ValueError: 不正なCPU集合を与えた

    Returns:
        str: 16進数のマスク値文字列
    """
    m = 0
    for c in cpus:
        if c < 0:
            raise ValueError(f"Invalid CPU id: {c}")
        m |= (1 << c)
    return f"{m:x}"

def write_text(path: Path, valid_paths: set[Path], text: str, dry: bool, verbose: bool) -> bool:
    """指定されたパスに値を書き込む

    Args:
        path (Path): 書き込み先パス
        valid_paths (set[Path]): /proc/interrupts上有効なパス
        text (str): 書き込む文字列
        dry (bool): 実際に書き込まずに書き込む値を表示する
        verbose (bool): 冗長表示

    Returns:
        bool: 書き込みに成功した場合は真
    """
    try:
        if dry:
            print(f"[DRY] echo {text!r} > {path}")
            return True
        path.write_text(text + "\n")
        if verbose:
            print(f"[OK ] wrote {text!r} to {path}")
        return True
    except Exception as e:
        if valid_paths and path not in valid_paths:
            # /proc/interruptsに含まれない割込みについては, 書き込みエラーを無視する
            # (*)OSに割込みハンドラが登録されていない割込み
            print(f"[OK ] Can not write unused irq {path}, ignored.")
            return True

        print(f"[NG ] write {path}: {e}")
        return False

def set_default_affinity_hex(hexmask: str, dry: bool, verbose: bool) -> bool:
    """デフォルトの割込みSMP Affinityを書き込む

    Args:
        hexmask (str): 書き込む値
        dry (bool): 実際に書き込まずに書き込む値を表示する
        verbose (bool): 冗長表示

    Returns:
        bool: 成功した場合は真
    """
    p = Path(IRQ_DEFAULT_SMP_AFFINITY)
    if not p.exists():
        print(f"[NG ] {p} does not exists.")
        return False
    return write_text(p, set(), hexmask, dry, verbose)

def set_all_irqs(cpulist: str, hexmask: str, mode: str, dry: bool, verbose: bool) -> tuple[int, int]:
    """既存の全 IRQ に対し, mode に応じて設定

    Args:
        cpulist (str): CPUリスト形式文字列
        hexmask (str): 書き込むCPUマスクを表す16進数文字列
        mode (str):
            - "list" /proc/irq/*/smp_affinity_list に cpulist を書く
            - "hex"  /proc/irq/*/smp_affinity に hexmask を書く
        dry (bool): 実際に書き込まずに書き込む値を表示する
        verbose (bool): 冗長表示

    Returns:
        tuple[int, int]: (書き込み成功数, 書き込み失敗数) のタプル
    """

    valid_irqs_dict=parse_interrupts() # 有効なIRQ番号から/proc/interruptへの辞書を取得
    ok = 0
    ng = 0
    if mode == "list":
        targets = [Path(p) for p in glob(os.path.join(PROC_IRQ_DIR,'[0-9]*','smp_affinity_list'))]
        valid_paths=set([Path(os.path.join(PROC_IRQ_DIR,str(irq),'smp_affinity_list')) for irq in sorted(valid_irqs_dict.keys())])
        payload = cpulist
    else:
        targets = [Path(p) for p in glob(os.path.join(PROC_IRQ_DIR,'[0-9]*','smp_affinity'))]
        valid_paths=set([Path(os.path.join(PROC_IRQ_DIR,str(irq),'smp_affinity')) for irq in sorted(valid_irqs_dict.keys())])
        payload = hexmask

    for p in targets:
        # 一部 IRQ は immutable ( 書けない ) .失敗はカウントだけ.
        if write_text(p, valid_paths, payload, dry, verbose):
            ok += 1
        else:
            ng += 1
    return ok, ng

def main():

    ap = argparse.ArgumentParser(
        description="Set IRQ default and/or existing IRQ CPU affinity from a cpulist."
    )

    ap.add_argument("--cpulist", required=True,
                    help='例: "0-1,4,6-7" ( 既定は default_smp_affinityは16進数, 各IRQは cpulist で反映する ) ')
    ap.add_argument("--set-default", action="store_true",
                    help="default_smp_affinity ( 16進マスク ) を設定する")
    ap.add_argument("--set-existing", action="store_true",
                    help="既存の /proc/irq/* の親和度を一括設定する")
    ap.add_argument("--existing-mode", choices=["list", "hex"], default="list",
                    help='既存 IRQ への書き込み方式: "list"=smp_affinity_list ( 既定 ) , "hex"=smp_affinity')
    ap.add_argument("--dry-run", action="store_true", help="書き込みせず動作のみ表示")
    ap.add_argument("--verbose", action="store_true", help="詳細ログ")
    args = ap.parse_args()

    if os.geteuid() != 0:
        print("[ERR] root privilege is needed!")
        sys.exit(1)

    try:
        target = parse_cpulist(args.cpulist)
    except Exception as e:
        print(f"[ERR] --cpulist is invalid: {e}")
        sys.exit(2)

    online = read_online_cpus()
    if online and not target.issubset(online):
        missing = sorted(target - online)
        print(f"[WARN] offline cpus are included!: {missing} continue.")

    hexmask = cpuset_to_hexmask(target)
    if args.verbose:
        print(f"[INFO] cpulist={sorted(target)} -> hexmask=0x{hexmask}")

    any_action = False

    if args.set_default:
        any_action = True
        ok = set_default_affinity_hex(hexmask, args.dry_run, args.verbose)
        if not ok:
            print("[NG ] Can not modify default_smp_affinity. ")

    if args.set_existing:
        any_action = True
        ok, ng = set_all_irqs(args.cpulist, hexmask, args.existing_mode, args.dry_run, args.verbose)
        mode = "smp_affinity_list" if args.existing_mode == "list" else "smp_affinity(hex)"
        print(f"[SUM] set_existing ({mode}) ok={ok}, ng={ng}")

    if not any_action:
        print("[INFO] Nothing to be done. --set-default or --set-existing should be set!")

if __name__ == "__main__":
    main()
    exit(0)
