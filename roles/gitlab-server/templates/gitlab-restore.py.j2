#!/usr/bin/env python3
# -*- mode: python; coding: utf-8; line-endings: unix -*-
# SPDX-License-Identifier: BSD-2-Clause
# Copyright (c) 2025 TAKEHARU KATO
#
# This file is distributed under the two-clause BSD license.
# For the full text of the license, see the LICENSE file in the project root directory.
# このファイルは2条項BSDライセンスの下で配布されています。
# ライセンス全文はプロジェクト直下の LICENSE を参照してください。
#
# OpenAI's ChatGPT partially generated this code.
# Author has modified some parts.
# OpenAIのChatGPTがこのコードの一部を生成しました。
# 著者が修正している部分があります。
#
# This file is generated by ansible.
# {# 日付の取得 #}
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}
#

"""GitLab Omnibusのバックアップからの復元を補助するスクリプト

root権限で実行されることを想定している。

/srv/gitlab/scripts/gitlab-restore.py --verbose <バックアップバンドルファイルのパス>
のようにgitlab-backup.pyで作成したバックアップバンドルファイルを指定してすることで,
GitLab公式のリストアコマンドによる復元処理を実行する。

処理内容は以下の通り:

1. バックアップバンドルファイルを展開し, メタ情報とバックアップアーカイブを取得する。
2. GitLab設定ファイル(gitlab.rb, gitlab-secrets.json)を復元する。
3. バックアップアーカイブをGitLabバックアップディレクトリに配置する。
4. pumaとsidekiqサービスを停止する。
5. gitlab-backup restore コマンドを実行して復元処理を行う。
6. gitlab-ctl reconfigure と gitlab-ctl start を実行してGitLabを再構成し起動する。
7. pumaとsidekiqサービスが稼働状態になるのを待機する。

実行例:
 # /srv/gitlab/scripts/gitlab-restore.py --verbose /srv/gitlab/daily-backup/gitlab-backup.tar.gz
 Restoring configuration files...
   Restored: gitlab.rb with uid={{gitlab_user_id}}, gid={{gitlab_group_id}}
   Restored: gitlab-secrets.json with uid={{gitlab_user_id}}, gid={{gitlab_group_id}}
 Restored 2 configuration file(s)
 Staged backup archive: /srv/gitlab/data/backups/1765706413_2025_12_14_18.6.2_gitlab_backup.tar
 Stopping puma and sidekiq services...
 Detected puma state 'down' via 'down: puma:'
 Detected sidekiq state 'down' via 'down: sidekiq:'
 Restoring backup ID 1765706413_2025_12_14_18.6.2...
 Reconfiguring and starting GitLab...
 Waiting for puma and sidekiq services to be running...
 Detected puma state 'run' via 'run: puma:'
 Detected sidekiq state 'run' via 'run: sidekiq:'
 Restore completed successfully

設定ファイルの復元をスキップする実行例:
 # /srv/gitlab/scripts/gitlab-restore.py --skip-config --verbose /srv/gitlab/daily-backup/gitlab-backup.tar.gz
 Skipping configuration files restoration
 Staged backup archive: /srv/gitlab/data/backups/1765706413_2025_12_14_18.6.2_gitlab_backup.tar
 (以降は通常と同じ)
"""

from __future__ import annotations

import argparse
import json
import os
import re
import shutil
import subprocess
import sys
import tarfile
import tempfile
import time
from pathlib import Path
from typing import Any, Final, NoReturn, Sequence, cast


# メタデータファイル名
METADATA_FILENAME: Final[str] = "metadata.json"

# バンドル内の設定ファイルプレフィックス
CONFIG_FILE_PREFIX: Final[str] = "config/"

# コマンド出力からのサービス状態取得の例
# docker exec -it gitlab gitlab-ctl stop 実行例:
# ok: down: alertmanager: 0s, normally up
# ok: down: gitaly: 0s, normally up
# ok: down: gitlab-exporter: 0s, normally up
# ok: down: gitlab-kas: 1s, normally up
# ok: down: gitlab-workhorse: 0s, normally up
# ok: down: logrotate: 0s, normally up
# ok: down: nginx: 1s, normally up
# ok: down: postgres-exporter: 0s, normally up
# ok: down: postgresql: 1s, normally up
# ok: down: prometheus: 0s, normally up
# ok: down: puma: 0s, normally up
# ok: down: redis: 0s, normally up
# ok: down: redis-exporter: 0s, normally up
# ok: down: registry: 1s, normally up
# ok: down: sidekiq: 1s, normally up
# ok: down: sshd: 0s, normally up
# docker exec -it gitlab gitlab-ctl start 実行例:
# ok: run: alertmanager: (pid 1834) 1s
# ok: run: gitaly: (pid 1844) 0s
# ok: run: gitlab-exporter: (pid 1866) 0s
# ok: run: gitlab-kas: (pid 1877) 0s
# ok: run: gitlab-workhorse: (pid 1884) 0s
# ok: run: logrotate: (pid 1897) 1s
# ok: run: nginx: (pid 1903) 0s
# ok: run: postgres-exporter: (pid 1917) 0s
# ok: run: postgresql: (pid 1927) 1s
# ok: run: prometheus: (pid 1935) 0s
# ok: run: puma: (pid 1955) 1s
# ok: run: redis: (pid 1960) 0s
# ok: run: redis-exporter: (pid 1968) 1s
# ok: run: registry: (pid 1986) 0s
# ok: run: sidekiq: (pid 1995) 0s
# ok: run: sshd: (pid 2001) 1s

# サービス停止状態のコマンド出力パターンテンプレート
SERVICE_STOP_PATTERN_TEMPLATE: Final[str] = r"^\s*(?:ok:\s+)?down:\s+{service}(?::|\\b)"
# サービス稼働状態のコマンド出力パターンテンプレート
SERVICE_RUN_PATTERN_TEMPLATE: Final[str] = r"^\s*(?:ok:\s+)?run:\s+{service}(?::|\\b)"

# GitLab のデフォルト UID/GID
GITLAB_UID: Final[int] = {{gitlab_user_id|default(998)}}
GITLAB_GID: Final[int] = {{gitlab_group_id|default(998)}}

def parse_args() -> argparse.Namespace:
    """復元スクリプトの引数を解析する。

    Returns:
        argparse.Namespace: 解析された引数情報。

    Examples:
        >>> import sys
        >>> original = sys.argv
        >>> sys.argv = ["gitlab-restore.py", "bundle.tar.gz"]
        >>> ns = parse_args()
        >>> ns.bundle
        'bundle.tar.gz'
        >>> sys.argv = original
    """

    parser: argparse.ArgumentParser = argparse.ArgumentParser(description="Restore GitLab from backup bundle")
    parser.add_argument("bundle", help="Path to the backup bundle tar.gz")
    parser.add_argument("--docker-cli", default=os.environ.get("DOCKER_CLI", "docker"),
                        help="Path to the docker command-line tool (default: %(default)s)")
    parser.add_argument("--container", default="{{ gitlab_container_name }}",
                        help="Name of the GitLab container (default: %(default)s)")
    parser.add_argument("--backup-dir", default="{{ gitlab_backup_dir }}",
                        help="GitLab backup storage directory (default: %(default)s)")
    parser.add_argument("--config-dir", default="{{ gitlab_config_dir }}",
                        help="GitLab configuration directory (default: %(default)s)")
    parser.add_argument("--check-interval", type=float, default=3.0,
                        help="Seconds between service status checks (default: %(default)s)")
    parser.add_argument("--timeout", type=float, default=120.0,
                        help="Seconds to wait for service state transitions (default: %(default)s)")
    parser.add_argument("--skip-config", action="store_true",
                        help="Skip restoring configuration files (gitlab.rb, gitlab-secrets.json), (default: %(default)s)")
    parser.add_argument("--verbose", action="store_true",
                        help="Enable verbose logging during state checks (default: %(default)s)")
    return parser.parse_args()


def abort(message: str, exit_code: int = 1) -> NoReturn:
    """エラー理由を表示して指定コードで終了する。

    Args:
        message (str): エラーメッセージ。
        exit_code (int): 終了コード。

    Raises:
        SystemExit: 指定した終了コードで送出される。

    Examples:
        >>> try:
        ...     abort("restore error", 2)
        ... except SystemExit as exc:
        ...     exc.code
        2
    """

    print(f"ERROR: {message}", file=sys.stderr)
    sys.exit(exit_code)


def run_command(command: list[str]) -> subprocess.CompletedProcess[str]:
    """サブプロセスを実行して結果を取得する。

    Args:
        command (list[str]): 実行するコマンドと引数。

    Returns:
        subprocess.CompletedProcess[str]: 実行結果情報。

    Examples:
        >>> result = run_command(["echo", "ok"])
        >>> result.stdout.strip()
        'ok'
    """

    return subprocess.run(command, capture_output=True, text=True)


def ensure_file(path: Path) -> None:
    """指定パスに通常ファイルが存在することを保証する。

    Args:
        path (Path): 存在確認するファイルパス。

    Raises:
        SystemExit: ファイルが存在しない場合。

    Examples:
        >>> from pathlib import Path
        >>> from tempfile import NamedTemporaryFile
        >>> with NamedTemporaryFile() as tmp:
        ...     ensure_file(Path(tmp.name))
    """
    # ファイルではない場合は強制終了する
    if not path.is_file():
        abort(f"Required file not found: {path}")


def extract_bundle(
    bundle_path: Path,
) -> tuple[dict[str, str], Path, tempfile.TemporaryDirectory[str]]:
    """バックアップバンドルを展開してメタ情報を取得する。

    Args:
        bundle_path (Path): 対象となるtar.gzパス。

    Returns:
        tuple[dict[str, str], Path, tempfile.TemporaryDirectory[str]]: メタ情報, 展開したアーカイブへのパス, 一時ディレクトリ。

    Raises:
        SystemExit: バンドルが不正または必須ファイルを欠く場合。

    Examples:
        >>> from pathlib import Path
        >>> from tempfile import TemporaryDirectory
        >>> import tarfile
        >>> with TemporaryDirectory() as tmp:
        ...     bundle = Path(tmp) / "bundle.tar.gz"
        ...     with tarfile.open(bundle, "w:gz") as tar:
        ...         meta_path = Path(tmp) / "metadata.json"
        ...         meta_path.write_text('{"backup_id": "1", "archive_filename": "data.tar", "created_at": "2025-01-01T00:00:00"}')
        ...         data_path = Path(tmp) / "data.tar"
        ...         data_path.write_bytes(b"data")
        ...         tar.add(meta_path, arcname="metadata.json")
        ...         tar.add(data_path, arcname="data.tar")
        ...     metadata, archive, tempdir = extract_bundle(bundle)
        ...     (metadata["backup_id"], archive.name, bool(tempdir.name))
        ('1', 'data.tar', True)
        ...     tempdir.cleanup()
    """

    # バンドルファイルの存在を確認する
    ensure_file(bundle_path)
    # 一時ディレクトリを作成してバンドルの内容を展開する
    tempdir: tempfile.TemporaryDirectory[str] = tempfile.TemporaryDirectory()
    # 一時ディレクトリのPathオブジェクトを取得する
    tmp_path: Path = Path(tempdir.name)

    try:
        # バンドルのtar.gzを展開する
        with tarfile.open(bundle_path, mode="r:gz") as tar_file:
            tar_handle: tarfile.TarFile = tar_file
            members: list[str] = tar_handle.getnames()
            if METADATA_FILENAME not in members:
                # metadata.jsonが存在しない場合はエラー
                tempdir.cleanup()
                abort("Bundle is missing metadata.json")
            # tar.gzを展開する
            tar_handle.extractall(path=tmp_path)
    except tarfile.TarError as exc:
        # 展開に失敗した場合は, 一時ディレクトリを削除してエラー終了する
        tempdir.cleanup()
        abort(f"Failed to read bundle: {exc}")

    # メタデータファイルの存在を確認する
    metadata_path: Path = tmp_path / METADATA_FILENAME
    # ファイルが存在することを確認する
    ensure_file(metadata_path)

    # メタデータJSONを読み込む
    raw_metadata: Any | None = None
    try:
        # JSONを解析する
        raw_metadata = json.loads(metadata_path.read_text())
    except json.JSONDecodeError as exc:
        # 解析に失敗した場合は, 一時ディレクトリを削除してエラー終了する
        tempdir.cleanup()
        abort(f"Invalid metadata JSON: {exc}")

    if raw_metadata is None or not isinstance(raw_metadata, dict):
        # メタデータがJSONオブジェクトでない場合は, 一時ディレクトリを削除してエラー終了する
        tempdir.cleanup()
        abort("Invalid metadata format: expected JSON object")

    # メタデータのキーと値を文字列に変換する
    raw_metadata_dict: dict[Any, Any] = cast(dict[Any, Any], raw_metadata)
    metadata_items: dict[str, str] = {}
    for key, value in raw_metadata_dict.items():
        str_key: str = str(key)
        str_value: str = str(value)
        metadata_items[str_key] = str_value
    metadata: dict[str, str] = metadata_items

    # 必須メタデータフィールドの存在を確認する
    # backup_id, archive_filename, created_atの3つが必須
    #   backup_id はgitlab-backup restoreで指定する引数に使用する
    #   archive_filename は展開したアーカイブのファイル名
    #   created_at はバックアップ作成日時
    for key in ("backup_id", "archive_filename", "created_at"):
        value: str | None = metadata.get(key)
        if not value:
            tempdir.cleanup()
            abort(f"Metadata field '{key}' is missing or invalid")

    # 展開したアーカイブファイルの存在を確認する
    archive_tmp: Path = tmp_path / metadata["archive_filename"]
    ensure_file(archive_tmp)

    # 全て正常ならメタデータと展開したアーカイブパス, 一時ディレクトリを返す
    return metadata, archive_tmp, tempdir


def stage_archive(archive_tmp: Path, backup_dir: Path, gitlab_uid: int, gitlab_gid: int) -> Path:
    """GitLabデータディレクトリにアーカイブを配置する。

    Args:
        archive_tmp (Path): 展開したアーカイブパス。
        backup_dir (Path): GitLabバックアップディレクトリ。
        gitlab_uid (int): 設定するUID。
        gitlab_gid (int): 設定するGID。

    Returns:
        Path: 配置後のアーカイブパス。

    Examples:
        >>> from pathlib import Path
        >>> from tempfile import TemporaryDirectory
        >>> with TemporaryDirectory() as tmp:
        ...     archive = Path(tmp) / "data.tar"
        ...     archive.write_bytes(b"data")
        ...     target_dir = Path(tmp) / "dest"
        ...     staged = stage_archive(archive, target_dir)
        ...     staged.exists()
        True
    """

    # GitLabの復元処理で指定されたバックアップディレクトリを作成する
    backup_dir.mkdir(parents=True, exist_ok=True)
    # GitLabの復元処理で指定されたバックアップディレクトリにアーカイブを配置する
    destination: Path = backup_dir / archive_tmp.name
    # バンドル内のGitlabバックアップアーカイブ(.tarファイル)をコピーする
    shutil.copy2(archive_tmp, destination)
    # アーカイブファイルのオーナーとグループをgitlabユーザーに設定する
    os.chown(destination, gitlab_uid, gitlab_gid)
    return destination


def restore_config_files(
    tempdir_path: Path,
    config_dir: Path,
    docker_cli: str,
    container: str,
    gitlab_uid: int,
    gitlab_gid: int,
    verbose: bool = False,
) -> int:
    """バックアップバンドルから設定ファイルを復元する。

    Args:
        tempdir_path (Path): バンドル展開先の一時ディレクトリパス。
        config_dir (Path): GitLab設定ディレクトリ。
        docker_cli (str): dockerコマンドのパス。
        container (str): 対象コンテナ名。
        gitlab_uid (int): 設定するUID。
        gitlab_gid (int): 設定するGID。
        verbose (bool): True の場合, 復元状況を表示する。

    Returns:
        int: 復元した設定ファイル数。

    Examples:
        >>> from pathlib import Path
        >>> from tempfile import TemporaryDirectory
        >>> with TemporaryDirectory() as tmp:
        ...     tmpdir = Path(tmp) / "extract"
        ...     tmpdir.mkdir()
        ...     config_dir = Path(tmp) / "config"
        ...     config_dir.mkdir()
        ...     (tmpdir / "config").mkdir()
        ...     (tmpdir / "config" / "gitlab.rb").write_text("# test")
        ...     count = restore_config_files(tmpdir, config_dir, "docker", "gitlab")
        ...     count
        1
    """

    restored_count: int = 0

    # バンドル内のconfig/プレフィックスを持つファイルを検索
    config_bundle_dir: Path = tempdir_path / "config"

    if not config_bundle_dir.is_dir():
        if verbose:
            print("No configuration files found in backup bundle")
        return 0

    if verbose:
        print(f"Restoring configuration files to {config_dir}...")

    # config/ディレクトリ配下の各ファイルを復元
    for config_file in config_bundle_dir.iterdir():
        if not config_file.is_file():
            continue

        # 配置先のパスを構成
        destination: Path = config_dir / config_file.name

        # ファイルをコピー
        shutil.copy2(config_file, destination)

        # 所有者をGitLabユーザーに設定
        os.chown(destination, gitlab_uid, gitlab_gid)

        if verbose:
            print(f"  Restored: {config_file.name} with uid={gitlab_uid}, gid={gitlab_gid}")

        restored_count += 1

    return restored_count


def docker_exec(
    docker_cli: str,
    container: str,
    *args: str,
    interactive: bool = False,
    tty: bool = False,
) -> subprocess.CompletedProcess[str]:
    """docker exec を実行してコマンド結果を取得する。

    Args:
        docker_cli (str): dockerコマンドのパス。
        container (str): 対象コンテナ名。
        *args (str): コンテナ内で実行するコマンド。

    Returns:
        subprocess.CompletedProcess[str]: 実行結果。

    Examples:
        >>> docker_exec("docker", "gitlab", "echo", "ok")  # doctest: +SKIP
    """

    #
    # docker exec コマンドラインを構築する
    #
    command: list[str] = [docker_cli, "exec"]

    if interactive:
        # 標準入力を割り当てる場合
        command.append("-i")
    if tty:
        # 擬似TTYを割り当てる場合
        command.append("-t")

    # 対象コンテナ名を追加する
    command.append(container)
    # コンテナ内で実行するコマンドと引数を追加する
    command.extend(args)

    # コマンドを実行して結果を返す
    return run_command(command)


def docker_exec_checked(
    docker_cli: str,
    container: str,
    *args: str,
    expected_codes: Sequence[int] | None = None,
    interactive: bool = False,
    tty: bool = False,
) -> str:
    """docker exec の結果を検証して標準出力を返す。

    Args:
        docker_cli (str): dockerコマンドのパス。
        container (str): 対象コンテナ名。
        *args (str): コンテナ内で実行するコマンド。
        expected_codes (Sequence[int] | None): 許容する終了コード。
        interactive (bool): True の場合, 標準入力を割り当てて実行する。
        tty (bool): True の場合, 擬似TTYを割り当てて実行する。

    Returns:
        str: 標準出力と標準エラーを結合した文字列。

    Raises:
        SystemExit: コマンドが失敗した場合。

    Examples:
        >>> docker_exec_checked("docker", "gitlab", "echo", "ok")  # doctest: +SKIP
    """

    # 許容する終了コードを設定する
    allowed_codes: tuple[int, ...] = tuple(expected_codes) if expected_codes is not None else (0,)

    # docker exec を実行する
    result: subprocess.CompletedProcess[str] = docker_exec(
        docker_cli,
        container,
        *args,
        interactive=interactive,
        tty=tty,
    )

    # 終了コードを検証する
    if result.returncode not in allowed_codes:
        # 失敗した場合は, 標準出力と標準エラーを結合してエラーメッセージを表示して終了する
        combined: str = (result.stdout or "") + (result.stderr or "")
        abort(f"Command failed ({' '.join(args)}): {combined.strip()}")

    # 正常なら標準出力と標準エラーを結合して返す
    return (result.stdout or "") + (result.stderr or "")


def get_gitlab_uid_gid(docker_cli: str, container: str, verbose: bool = False) -> tuple[int, int]:
    """GitLabコンテナ内のgitユーザのUID/GIDを取得する。

    Args:
        docker_cli (str): dockerコマンドのパス。
        container (str): 対象コンテナ名。
        verbose (bool): True の場合、取得状況を表示する。

    Returns:
        tuple[int, int]: (UID, GID)のタプル。取得失敗時はデフォルト値。

    Examples:
        >>> get_gitlab_uid_gid("docker", "gitlab")  # doctest: +SKIP
        (998, 998)
    """

    try:
        # コンテナ内でid gitコマンドを実行してgitユーザの情報を取得
        result: subprocess.CompletedProcess[str] = subprocess.run(
            [docker_cli, "exec", container, "id", "git"],
            capture_output=True,
            text=True,
            timeout=5,
        )

        if result.returncode == 0:
            # uid=998(git) gid=998(git) groups=998(git) のような出力から抽出
            uid_match: re.Match[str] | None = re.search(r"uid=(\d+)", result.stdout)
            gid_match: re.Match[str] | None = re.search(r"gid=(\d+)", result.stdout)

            if uid_match and gid_match:
                uid: int = int(uid_match.group(1))
                gid: int = int(gid_match.group(1))
                if verbose:
                    print(f"Detected git user from container: uid={uid}, gid={gid}")
                return (uid, gid)
    except Exception as exc:
        if verbose:
            print(f"Failed to detect git user UID/GID from container: {exc}")

    # 取得に失敗した場合はデフォルト値を使用
    if verbose:
        print(f"Using default UID/GID: uid={GITLAB_UID}, gid={GITLAB_GID}")
    return (GITLAB_UID, GITLAB_GID)


def wait_for_service_state(
    docker_cli: str,
    container: str,
    service: str,
    expect: str,
    interval: float,
    timeout: float,
    *,
    verbose: bool = False,
) -> None:
    """GitLabサービスの状態遷移を待機する。

    Args:
        docker_cli (str): dockerコマンドのパス。
        container (str): 対象コンテナ名。
        service (str): 監視対象サービス名。
        expect (str): 期待する状態 ("run" か "down")。
        interval (float): 再試行間隔(秒)。
        timeout (float): タイムアウト(秒)。
        verbose (bool): True の場合, 検出した状態や待機状況を出力する。

    Raises:
        SystemExit: 期待状態にならなかった場合。

    Examples:
        >>> wait_for_service_state("docker", "gitlab", "puma", "run", 1.0, 5.0)  # doctest: +SKIP
    """

    # サービス状態検出用の正規表現パターンを構築する
    template: str | None = None
    if expect == "down":
        template = SERVICE_STOP_PATTERN_TEMPLATE
    elif expect == "run":
        template = SERVICE_RUN_PATTERN_TEMPLATE
    else:
        abort(f"Unsupported expected state '{expect}' for service {service}")

    # 正規表現パターンをコンパイルする
    pattern: re.Pattern[str] = re.compile(
        template.format(service=re.escape(service)),
        re.MULTILINE,
    )

    # タイムアウトまでループして状態を確認する
    deadline: float = time.time() + timeout
    while time.time() < deadline:

        # サービス状態を確認するためのコマンドを実行する
        result: subprocess.CompletedProcess[str] = docker_exec(
            docker_cli,
            container,
            "gitlab-ctl",
            "status",
            service,
        )
        # コマンド出力からサービス状態を検出する
        output: str = (result.stdout or "") + (result.stderr or "")
        match_obj: re.Match[str] | None = pattern.search(output)
        if verbose and match_obj:
            # 指定された状態を検出した場合は, その旨を出力する
            matched_line: str = match_obj.group(0)
            print(f"Detected {service} state '{expect}' via '{matched_line}'")
        if match_obj is not None:
            # 期待する状態を検出した場合は正常終了する
            return
        if verbose:
            # 状態が期待と異なる場合は, その旨を出力する
            print(f"Waiting for {service} to reach '{expect}' state...")

        # 指定された間隔だけ待機する
        time.sleep(interval)

    # タイムアウトに達しても期待状態にならなかった場合はエラー終了する
    abort(f"Service '{service}' did not reach state '{expect}' within {timeout} seconds")


def main() -> None:
    """コマンドラインからGitLab復元手順を実行する。

    Raises:
        SystemExit: 復元処理に失敗した場合。

    Examples:
        >>> main()  # doctest: +SKIP
    """

    # 引数を解析する
    args: argparse.Namespace = parse_args()

    # root権限での実行を確認する
    if os.geteuid() != 0:
        abort("This script must be run as root")

    # バンドルファイルパスを取得する
    bundle_path: Path = Path(args.bundle)

    metadata: dict[str, str]
    archive_tmp: Path
    tempdir: tempfile.TemporaryDirectory[str]

    # バンドルを展開してメタ情報とアーカイブパスを取得する
    metadata, archive_tmp, tempdir = extract_bundle(bundle_path)
    # 一時ディレクトリのPathオブジェクトを取得
    tmp_path: Path = Path(tempdir.name)
    # GitLabバックアップディレクトリパスを取得する
    backup_dir: Path = Path(args.backup_dir)
    # GitLab設定ディレクトリパスを取得する
    config_dir: Path = Path(args.config_dir)

    # GitLabコンテナからgitユーザのUID/GIDを取得する
    gitlab_uid: int
    gitlab_gid: int
    gitlab_uid, gitlab_gid = get_gitlab_uid_gid(args.docker_cli, args.container, verbose=args.verbose)

    try:
        # 設定ファイルを復元する
        if args.skip_config:
            if args.verbose:
                print("Skipping configuration files restoration")
        else:
            if args.verbose:
                print("Restoring configuration files...")
            config_count: int = restore_config_files(
                tmp_path,
                config_dir,
                args.docker_cli,
                args.container,
                gitlab_uid,
                gitlab_gid,
                verbose=args.verbose,
            )
            if config_count > 0 and args.verbose:
                print(f"Restored {config_count} configuration file(s)")

        # アーカイブをGitLabバックアップディレクトリに配置する
        staged_archive: Path = stage_archive(archive_tmp, backup_dir, gitlab_uid, gitlab_gid)
        print(f"Staged backup archive: {staged_archive}")

        # GitLab公式復元手順に従って, データベースを稼働させたまま
        # pumaとsidekiqサービスを停止してから復元処理を実施する
        if args.verbose:
            print("Stopping puma and sidekiq services...")
        docker_exec_checked(
            args.docker_cli,
            args.container,
            "gitlab-ctl",
            "stop",
            "puma",
            expected_codes=(0, 1),
        )
        docker_exec_checked(
            args.docker_cli,
            args.container,
            "gitlab-ctl",
            "stop",
            "sidekiq",
            expected_codes=(0, 1),
        )
        wait_for_service_state(
            args.docker_cli,
            args.container,
            "puma",
            "down",
            args.check_interval,
            args.timeout,
            verbose=args.verbose,
        )
        wait_for_service_state(
            args.docker_cli,
            args.container,
            "sidekiq",
            "down",
            args.check_interval,
            args.timeout,
            verbose=args.verbose,
        )

        # バックアップ復元処理を非対話的に実行する。
        # GITLAB_ASSUME_YES=1を指定することで対話確認をスキップする。
        # See: https://docs.gitlab.com/omnibus/gitlab-ctl.html#gitlab-backup-restore

        if args.verbose:
            print(f"Restoring backup ID {metadata['backup_id']}...")

        docker_exec_checked(
            args.docker_cli,
            args.container,
            "env",
            "GITLAB_ASSUME_YES=1",
            "gitlab-backup",
            "restore",
            f"BACKUP={metadata['backup_id']}",
        )

        # 復元後にGitLabを再構成してサービスを起動する
        if args.verbose:
            print("Reconfiguring and starting GitLab...")
        docker_exec_checked(args.docker_cli, args.container, "gitlab-ctl", "reconfigure")
        docker_exec_checked(args.docker_cli, args.container, "gitlab-ctl", "start")

        # pumaとsidekiqサービスが稼働状態になるのを待機する
        if args.verbose:
            print("Waiting for puma and sidekiq services to be running...")
        wait_for_service_state(
            args.docker_cli,
            args.container,
            "puma",
            "run",
            args.check_interval,
            args.timeout,
            verbose=args.verbose,
        )
        wait_for_service_state(
            args.docker_cli,
            args.container,
            "sidekiq",
            "run",
            args.check_interval,
            args.timeout,
            verbose=args.verbose,
        )

        print("Restore completed successfully")
    finally:
        tempdir.cleanup()


if __name__ == "__main__":
    main()
