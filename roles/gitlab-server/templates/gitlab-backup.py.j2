#!/usr/bin/env python3
# -*- mode: python; coding: utf-8; line-endings: unix -*-
# SPDX-License-Identifier: BSD-2-Clause
# Copyright (c) 2025 TAKEHARU KATO
#
# This file is distributed under the two-clause BSD license.
# For the full text of the license, see the LICENSE file in the project root directory.
# このファイルは2条項BSDライセンスの下で配布されています。
# ライセンス全文はプロジェクト直下の LICENSE を参照してください。
#
# OpenAI's ChatGPT partially generated this code.
# Author has modified some parts.
# OpenAIのChatGPTがこのコードの一部を生成しました。
# 著者が修正している部分があります。
#
# This file is generated by ansible.
# {# 日付の取得 #}
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}
#

"""GitLab Omnibusのバックアップ取得を補助するスクリプト

root権限で実行されることを想定している。
完了すると,
 Backup stored: <バックアップバンドルファイルのパス>
のようにデイリーバックアップファイル(バックアップバンドルファイル)へのパスを出力する。

処理内容は以下の通り:
1. 指定されたGitLabコンテナ内でgitlab-backup createコマンドを実行して
   GitLab公式のバックアップアーカイブを生成する。
2. 生成されたバックアップアーカイブと, メタ情報をまとめたtar.gz形式の
   バックアップバンドルファイルを作成する。

実行例:
# /srv/gitlab/scripts/gitlab-backup.py
Backup stored: /srv/gitlab/daily-backup/gitlab-backup.tar.gz
"""

from __future__ import annotations

import argparse
import datetime as dt
import json
import os
import re
import socket
import subprocess
import sys
import tarfile
import tempfile
from pathlib import Path
from typing import Final, Match, NoReturn

# 正規表現パターン: gitlab backup コマンド出力からのバックアップアーカイブ名抽出
# \s+(?P<filename>(?P<backup_id>[A-Za-z0-9._-]+)_gitlab_backup\.tar)
# GitLab バックアップ処理のログ行からバックアップファイル名とバックアップ ID を抽出する正規表現。
# \s+ がコロン後の空白を許容している。(?P<filename>...) でファイル名全体を名前付きキャプチャし,
# その内部で (?P<backup_id>[A-Za-z0-9._-]+) を用いて, 拡張子や区切り文字を含むバックアップ ID を
# 取得し, 末尾の固定文字列 '_gitlab_backup.tar' を続けることで, 想定されたログファイル形式だけに
# マッチするよう制約をかける。
BACKUP_ARCHIVE_PATTERN: Final[re.Pattern[str]] = re.compile(
    r"Creating backup archive:\s+(?P<filename>(?P<backup_id>[A-Za-z0-9._-]+)_gitlab_backup\.tar)",
    re.IGNORECASE,
)


def parse_args() -> argparse.Namespace:
    """バックアップスクリプトの引数を解析する。

    Returns:
        argparse.Namespace: 解析された引数情報。

    Examples:
        >>> import sys
        >>> original = sys.argv
        >>> sys.argv = ["gitlab-backup.py", "--container", "dummy"]
        >>> ns = parse_args()
        >>> ns.container
        'dummy'
        >>> sys.argv = original
    """

    parser: argparse.ArgumentParser = argparse.ArgumentParser(description="Create and archive GitLab backups")
    parser.add_argument("--docker-cli", default=os.environ.get("DOCKER_CLI", "docker"))
    parser.add_argument("--container", default="{{ gitlab_container_name }}")
    parser.add_argument("--backup-dir", default="{{ gitlab_backup_dir }}")
    parser.add_argument("--daily-dir", default="{{ gitlab_daily_backup_dir }}")
    return parser.parse_args()


def abort(message: str, exit_code: int = 1) -> NoReturn:
    """エラー内容を通知しつつ終了コードを設定して終了する。

    Args:
        message (str): エラーメッセージ。
        exit_code (int): 終了コード。

    Raises:
        SystemExit: 指定した終了コードで送出される。

    Examples:
        >>> try:
        ...     abort("failure", 5)
        ... except SystemExit as exc:
        ...     exc.code
        5
    """

    print(f"ERROR: {message}", file=sys.stderr)
    sys.exit(exit_code)


def run_gitlab_backup(docker_cli: str, container: str) -> dict[str, str]:
    """GitLabコンテナ内でバックアップを実行する。

    Args:
        docker_cli (str): dockerコマンドの実行パス。
        container (str): 対象となるGitLabコンテナ名。

    Returns:
        dict[str, str]: 取得したバックアップIDやアーカイブ名を保持する情報。

    Raises:
        SystemExit: バックアップ生成に失敗した場合。

    Examples:
        >>> # 実行環境にDockerが必要であるためスキップする
        >>> run_gitlab_backup("docker", "gitlab")  # doctest: +SKIP
    """

    # GitLabコンテナ内でgitlab-backup createコマンドを実行する
    cmd: list[str] = [docker_cli, "exec", "-t", container, "gitlab-backup", "create"]
    result: subprocess.CompletedProcess[str] = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        # バックアップ生成に失敗した場合, 標準出力と標準エラー出力を結合して
        # エラーメッセージを表示して終了する
        combined: str = (result.stdout or "") + (result.stderr or "")
        abort(f"gitlab-backup create failed: {combined.strip()}")

    # バックアップ生成に成功した場合, 出力からバックアップアーカイブ名を抽出する
    match: Match[str] | None = BACKUP_ARCHIVE_PATTERN.search(result.stdout or "")
    if match is None:
        # バックアップアーカイブ名の抽出に失敗した場合, エラーで終了する
        abort("Failed to parse backup archive name from gitlab-backup output")

    # 抽出に成功した場合, バックアップIDとアーカイブ名を辞書で返す
    return {
        "backup_id": match.group("backup_id"),
        "archive_name": match.group("filename"),
        "raw_stdout": result.stdout,
    }


def ensure_directory(path: Path) -> None:
    """指定ディレクトリを作成してディレクトリの存在を保証する。

    Args:
        path (Path): 作成対象ディレクトリ。

    Raises:
        SystemExit: ディレクトリ作成に失敗した場合。

    Examples:
        >>> from pathlib import Path
        >>> from tempfile import TemporaryDirectory
        >>> with TemporaryDirectory() as tmp:
        ...     target = Path(tmp) / "nested"
        ...     ensure_directory(target)
        ...     target.is_dir()
        True
    """

    try:
        path.mkdir(parents=True, exist_ok=True)
    except Exception as exc:  # pragma: no cover - defensive
        abort(f"Unable to create directory {path}: {exc}")


def build_metadata(
    backup_info: dict[str, str],
    archive_path: Path,
    now: dt.datetime,
    container: str,
) -> dict[str, str]:
    """バックアップのメタ情報を辞書形式で返却する

    Args:
        backup_info (dict[str, str]): バックアップIDとファイル名。
        archive_path (Path): バックアップアーカイブのパス。
        now (datetime.datetime): 作成日時。
        container (str): バックアップ元コンテナ名。

    Returns:
        dict[str, str]: メタ情報を格納した辞書。

    Raises:
        SystemExit: バックアップアーカイブが存在しない場合。

    Examples:
        >>> import datetime as dt
        >>> from pathlib import Path
        >>> from tempfile import TemporaryDirectory
        >>> with TemporaryDirectory() as tmp:
        ...     archive = Path(tmp) / "dummy.tar"
        ...     _ = archive.write_bytes(b"test")
        ...     info = {"backup_id": "123", "archive_name": "dummy.tar"}
        ...     data = build_metadata(info, archive, dt.datetime(2025, 1, 1), "gitlab")
        ...     data["backup_id"], data["archive_filename"]
        ('123', 'dummy.tar')
    """

    if not archive_path.exists():
        # バックアップアーカイブが存在しない場合, エラーで終了する
        abort(f"Backup archive not found: {archive_path}")

    # メタ情報を辞書形式で構築する
    metadata: dict[str, str] = {
        "backup_id": backup_info["backup_id"],
        "archive_filename": backup_info["archive_name"],
        "archive_path": str(archive_path),
        "created_at": now.replace(microsecond=0).isoformat(),
        "created_by_host": socket.gethostname(),
        "container_name": container,
    }
    return metadata


def write_bundle(archive_path: Path, metadata: dict[str, str], bundle_path: Path) -> None:
    """バックアップアーカイブとメタ情報をtar.gzにまとめる。

    Args:
        archive_path (Path): バックアップアーカイブのパス。
        metadata (dict[str, str]): メタ情報の辞書。
        bundle_path (Path): 生成するtar.gzパス。

    Raises:
        SystemExit: ディレクトリ作成に失敗した場合。

    Examples:
        >>> from pathlib import Path
        >>> from tempfile import TemporaryDirectory
        >>> import tarfile
        >>> with TemporaryDirectory() as tmp:
        ...     archive = Path(tmp) / "dummy.tar"
        ...     archive.write_bytes(b"data")
        ...     bundle = Path(tmp) / "bundle.tar.gz"
        ...     write_bundle(archive, {"backup_id": "1", "archive_filename": "dummy.tar"}, bundle)
        ...     tarfile.is_tarfile(bundle)
        True
    """

    # 一時ディレクトリを作成してメタ情報ファイルを生成する
    with tempfile.TemporaryDirectory() as tmpdir:
        # メタ情報格納先ファイルのパスを構成する
        tmpdir_path: Path = Path(tmpdir)
        metadata_path: Path = tmpdir_path / "metadata.json"
        # メタ情報をJSON形式でファイルに書き込む
        metadata_path.write_text(json.dumps(metadata, indent=2, sort_keys=True))

        # バックアップアーカイブとメタ情報をtar.gzにまとめたバンドルファイルを作成する
        ensure_directory(bundle_path.parent)
        tmp_bundle: Path = tmpdir_path / "bundle.tar.gz"
        with tarfile.open(tmp_bundle, mode="w:gz") as tar_file:
            tar_handle: tarfile.TarFile = tar_file
            tar_handle.add(archive_path, arcname=archive_path.name)
            tar_handle.add(metadata_path, arcname="metadata.json")

        # バンドルファイルを最終的なバンドルパスに移動する
        tmp_bundle.replace(bundle_path)


def main() -> None:
    """コマンドラインからバックアップ処理を実行する。

    Raises:
        SystemExit: 各処理で致命的なエラーが発生した場合。

    Examples:
        >>> # 実運用向けコマンドであるためスキップする
        >>> main()  # doctest: +SKIP
    """

    # コマンドライン引数を解析する
    args: argparse.Namespace = parse_args()

    # バックアップ保存先ディレクトリと日次バックアップディレクトリの存在を保証する
    backup_dir: Path = Path(args.backup_dir)
    daily_dir: Path = Path(args.daily_dir)
    ensure_directory(backup_dir)
    ensure_directory(daily_dir)

    # バックアップ取得日時を取得する
    now: dt.datetime = dt.datetime.now(dt.timezone.utc)

    # GitLabコンテナ内で公式手順で指定されたバックアップコマンドを実行する
    backup_info: dict[str, str] = run_gitlab_backup(args.docker_cli, args.container)

    # 取得したGitLab公式バックアップアーカイブのパスを構成する
    archive_path: Path = backup_dir / backup_info["archive_name"]
    # バックアップのメタ情報を構築する
    metadata: dict[str, str] = build_metadata(backup_info, archive_path, now, args.container)

    # バックアップアーカイブとメタ情報をまとめたバンドルファイルを作成する
    bundle_name: str = "{{ gitlab_backup_bundle_file|default("gitlab-backup.tar.gz", true) }}"
    bundle_path: Path = daily_dir / bundle_name

    # バンドルファイルを書き込む
    write_bundle(archive_path, metadata, bundle_path)

    # バックアップ完了を通知する
    print(f"Backup stored: {bundle_path}")


if __name__ == "__main__":
    main()
