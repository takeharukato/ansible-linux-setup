#!/usr/bin/env bash
#
#  -*- coding:utf-8 mode:bash -*-
# This file is generated by ansible.
{# 日付の取得 #}
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}

#
# netgaugeの実行
#

set -euo pipefail

SCRIPT_DIR=$(cd $(dirname $0); pwd)

# ==== 設定 ====
CGROUP_ROOT="/sys/fs/cgroup"
SLICE_NAME="kubepods.slice"
PATH_SLICE="${CGROUP_ROOT}/${SLICE_NAME}"
CG_PATH_APP="${PATH_SLICE}/netgauge-app"
NG_BIN="${NG_BIN:-{{ netgauge_dir }}/bin/netgauge}"     # Netgauge 実行ファイルパス
MODE="${1:-fwq}"                   # fwq | ftq
DURATION_SEC="${DURATION_SEC:-10}" # 計測秒数 ( 必要に応じて調整 )
QUANTUM_US="${QUANTUM_US:-50}"     # FWQ/FTQの量子 ( マイクロ秒 )
OUT_BASE="${OUT_BASE:-./runs}"

if [[ ! -x "${NG_BIN}" ]]; then
  echo "ERROR: NG_BIN=${NG_BIN} not found or not executable." >&2
  exit 1
fi
if [[ ! -f .cpu_env ]]; then
  echo "Run ./00_detect_cpus.sh first." >&2
  exit 1
fi
# shellcheck disable=SC1091
source .cpu_env
if [ "x${RUN_DIR}" = "x" ]; then
    TS="$(date +%Y%m%d-%H%M%S)"
    RUN_DIR="${OUT_BASE}/${MODE}-${TS}"
fi
mkdir -p "${RUN_DIR}"

# 実行オプション ( Netgaugeのnoiseエンジン )
#  FWQ, 量子 50µs, サンプル 200k, トレースをファイル出力
#   例: ./netgauge -m dummy -x noise -e fwq -d 50 -s 200000
NG_ARGS=(-m dummy -x noise -e "${MODE}" -s "${DURATION_SEC}")
if [[ "${MODE}" == "fwq" ]]; then
  NG_ARGS+=(-d "${QUANTUM_US}")
elif [[ "${MODE}" == "ftq" ]]; then
  NG_ARGS+=(-d "${QUANTUM_US}")
else
  echo "Unsupported MODE=${MODE}. Use fwq or ftq." >&2
  exit 1
fi

# メタ情報保存
{
  echo "MODE=${MODE}"
  echo "DURATION_SEC=${DURATION_SEC}"
  echo "QUANTUM_US=${QUANTUM_US}"
  echo "NG_BIN=${NG_BIN}"
  echo "HK_RANGE=${HK_RANGE}"
  echo "APP_RANGE=${APP_RANGE}"
  echo "APP_N=${APP_N}"
} > "${RUN_DIR}/meta.env"

echo "[INFO] Launching ${MODE} on ${APP_N} cores: ${APP_RANGE}"
command -v mpirun >/dev/null 2>&1 && HAVE_MPI=1 || HAVE_MPI=0

# ==== cgroup へ投入するヘルパ ====
push_to_cgroup() {
  local pid="$1"
  local cg="${CG_PATH_APP}/cgroup.procs"

  if [[ -w "${cg}" ]]; then
    echo "${pid}" > "${cg}"
  fi
}

# ==== CPUリストを配列化 ====
readarray -t APP_IDS < <(python3 "${SCRIPT_DIR}/50_cpu_list.py")

# ==== 実行 ( MPIあり/なしで分岐 )  ====
if [[ "${HAVE_MPI}" -eq 1 ]]; then
  echo "[INFO] Using MPI"
  # Open MPI の例: 1プロセス=1コアで物理コアにピン
  # 必要に応じて --report-bindings など追加可
  # rank毎の出力を分けるために --output-filename を利用
  mpirun -np "${APP_N}" \
    --bind-to core --map-by ppr:1:core \
    --cpu-set "${APP_RANGE}" \
    --output-filename "${RUN_DIR}/rank" \
    "${NG_BIN}" "${NG_ARGS[@]}"

  # Open MPIのoutputファイルは rank/0/stdout 等になる実装もあるので正規化
  find "${RUN_DIR}" -type f -name "rank*.txt" -o -name "rank*.stdout" -o -name "rank.*.stdout" 2>/dev/null | while read -r f; do
    base="$(basename "$f")"
    # rank.0.stdout -> rank0000.out 的に揃える
    num="$(echo "$base" | grep -Eo '[0-9]+' | tail -n1)"
    printf -v tag "rank%04d.out" "${num:-0}"
    cp -f "$f" "${RUN_DIR}/${tag}"
  done

else
  echo "[INFO] No MPI found."

  i=0
  pids=()
  for cpu in "${APP_IDS[@]}"; do
      printf -v rank "rank%04d" "${i}"
      rankdir=`realpath ${RUN_DIR}/${rank}`
      mkdir -p "${rankdir}"
      printf -v tag "rank%04d.out" "${i}"
      printf -v stdout_tag "rank%04d.stdout" "${i}"
      # まず自身のPIDをcgroupへ入れる
      push_to_cgroup "$$" || true
      cwd=`pwd`
      cd "${rankdir}"
      # tasksetで固定
      echo "taskset -c ${i} ${NG_BIN} ${NG_ARGS[@]}"
      #numactl --physcpubind="${cpu}" \
	  taskset -c "${i}" \
           "${NG_BIN}" "${NG_ARGS[@]}" |tee "${rankdir}/${stdout_tag}" 2>&1
      if [ -f ng.out ]; then
	  cp ng.out "${rankdir}/${tag}"
      fi
      cd "${cwd}"
      pids+=("$!")
    ((i++))
  done

  # 待機
  wait

  # スライスを削除する
  nr_procs=`cat "${CG_PATH_APP}/cgroup.procs"|wc -l`

  if [ "${nr_procs}" == "0" ]; then
    sudo rmdir "${CG_PATH_APP}"
  fi

fi

echo "[OK] Netgauge run finished: ${RUN_DIR}"

echo "次は ./25_flatten_values.sh ${RUN_DIR} を実行してください。"
