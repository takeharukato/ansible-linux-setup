#!/usr/bin/env bash
# -*- coding: utf-8 mode: bash -*-
# Copyright 2025 Takeharu KATO  All Rights Reserved.
# SPDX-License-Identifier: BSD-2-Clause
# Notes: Portions of this codebase were initially drafted with ChatGPT assistance.
#
# This file is generated by ansible.
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}
#
# 配置先: {{k8s_node_setup_tools_dir}}/create-embedded-kubeconfig.sh
#
# 概要:
#   指定されたK8sのadmin.confを基に, 証明書を埋め込んだkubeconfigファイルを作成する。
#  作成されたkubeconfigファイルは, CiliumのCluster Mesh機能で使用される。
# 使用法:
#   環境変数 CLUSTER_NAME にクラスタ名を指定してスクリプトを実行する。
#   例:
#     CLUSTER_NAME="my-cluster" ./create-embedded-kubeconfig.sh
# 環境変数:
#   KUBE_ADMIN_CONF Kubernetesのadmin.confファイル
#                   デフォルト値は, /etc/kubernetes/admin.conf
#   CLUSTER_NAME    Cilium Cluster Mesh機能のクラスタ名 ( 必須 )
#   OUTPUT_DIR      作成されたkubeconfigファイルの出力先ディレクトリ
#                   デフォルト値は, カレントディレクトリとなる
#   FILE_NAME_PREFIX 作成されるkubeconfigファイルの名前の接頭辞
#                   デフォルト値は, "{{ k8s_embed_kubeconfig_file_prefix | default('') }}"
#   FILE_NAME_POSTFIX 作成されるkubeconfigファイルの名前の接尾辞
#                     デフォルト値は, "{{ k8s_embed_kubeconfig_file_postfix | default('-embedded.kubeconfig') }}"
#   LOG_LEVEL  : ログレベル 以下の出力条件に基づいてメッセージ出力を制御する (default: 2)
#               出力メッセージの前に, ログ種別を示すプレフィックスが付与される
#               0以上の整数値を指定可能
#                - LOG_LEVEL=0,1 は将来予約
#                - LOG_LEVEL=2 (デフォルト値)では Errorのみ出力 (Info/Warningは出ない)。
#                - LOG_LEVEL=3 では Warning と Error が出力 (Info/Debugは出ない)。
#                - LOG_LEVEL=4 では Info, Warning と Error が出力 (Debugは出ない)。
#                - LOG_LEVEL=5 で 全レベル (Debug/Info/Warning/Error)が出力。
#
# ログ種別, プレフィックス, 出力条件:
#
#               ログ種別   プレフィックス    出力条件 (この条件を満たす場合に出力される)
#               Debug      [Debug]           LOG_LEVEL > 4
#               Info       [Info]            LOG_LEVEL > 3
#               Warning    [Warning]         LOG_LEVEL > 2
#               Error      [Error]           LOG_LEVEL > 1
#               Assert     [Assert]          スクリプトの動作に致命的な影響を及ぼす前提条件/前提環境条件に
#                                            関わるメッセージであることから, LOG_LEVEL に関係なく出力される
#メッセージ一覧:
#   [Info] ===== kubeconfig summary <ファイルフィンガープリント> =====
#          kubeconfigファイルの概要ヘッダ表示, 後続の行に以下の各種情報をInfoメッセージとして表示する。
#          file-path: <kubeconfigファイルパス>
#          sha256: <kubeconfigファイルのSHA256ハッシュ値>
#          contexts: <context一覧>
#          clusters: <cluster一覧>
#          users:    <user一覧>
#          current-context: <current-context名>
#          context.cluster: <current-contextが参照するcluster名>
#          context.user:    <current-contextが参照するuser名>
#          cluster.server:  <current-contextが参照するclusterのserver値>
#          cluster.certificate-authority-data: present (len=<長さ>, head='<先頭16バイト>...')
#          cluster.certificate-authority: file='<ファイルパス>' (exists)
#
#   [Info] ===== end of summary <ファイルフィンガープリント> =====
#          kubeconfigファイルの概要終端表示
#
#   [Error] No cluster name specified, exit.
#           クラスタ名が指定されていない場合のエラーメッセージ
#           環境変数 CLUSTER_NAME が未設定, 空文字列, none の場合に出力される。
#
#   [Warning] certificate-authority-data is masked (DATA+OMITTED / REDACTED)
#           certificate-authority-data フィールドが DATA+OMITTED / REDACTED で
#           マスクされている場合の警告メッセージ
#
#   [Warning] cluster.certificate-authority: file='...' (NOT found)
#           certificate-authority フィールドで指定されたファイルが存在しない場合の警告メッセージ
#
#   [Warning] no CA found (neither data nor file)
#           certificate-authority-data, certificate-authority の両方が存在しない場合の警告メッセージ
#
#   [Warning] raw file contains masked fields (saved without --raw?)
#           kubeconfigファイルの先頭数行に DATA+OMITTED / REDACTED が含まれている場合の警告メッセージ
#
#   [Warning] No CA found; falling back to --insecure-skip-tls-verify
#           certificate-authority-data, certificate-authority の両方が存在しない場合に,
#           --insecure-skip-tls-verify オプションで cluster を作成する場合の警告メッセージ
#
#   [Error] Invalid argument: ... args=<関数の引数一覧>
#           関数の引数が不正な場合のエラーメッセージ
#
#   [Error] Cannot open file: <ファイルパス>
#           指定されたファイルが開けない場合のエラーメッセージ
#
#   [Error] Cannot create output directory: <ディレクトリパス>
#           指定された出力ディレクトリが作成できない場合のエラーメッセージ
#
# アサーションエラー, 到達不可能コード到達メッセージについて:
#
# 本スクリプトでは, 内部整合性エラーを検出した場合に, アサーションエラー,
# 到達不可能コード到達メッセージを出力してスクリプトを終了する。
#
# メッセージの形式は以下の通り。
#
# [Assert] Assertion error: <条件式文字列> file=<呼び出し元ファイル> line=<呼び出し元の行番号>
# [Assert] Assertion error: <条件式文字列> file=<呼び出し元ファイル> line=<呼び出し元の行番号> <補足メッセージ>
# [Assert] Assertion error: <empty expression> file=<呼び出し元ファイル> line=<呼び出し元の行番号>
# [Assert] Reached unreachable code: file=<呼び出し元ファイル> line=<呼び出し元の行番号>
#
# これらのメッセージが出力された場合, スクリプトの修正が必要。
# なお, これらのメッセージは, スクリプトのバグに起因するため, LOG_LEVEL に関係なく出力される。

set -euo pipefail

# K8sのadmin.confファイル
KUBE_ADMIN_CONF="${KUBE_ADMIN_CONF:-/etc/kubernetes/admin.conf}"
# 更新後のクラスタ名
CLUSTER_NAME="${CLUSTER_NAME:-none}"
# 出力先ディレクトリ
OUTPUT_DIR="${OUTPUT_DIR:-none}"
# ファイルの名前の接尾辞
FILE_NAME_PREFIX="${FILE_NAME_PREFIX:-}"
# ファイルの名前の接尾辞
FILE_NAME_POSTFIX="${FILE_NAME_POSTFIX:-{{ k8s_embed_kubeconfig_file_postfix }}}"
# ログレベル
LOG_LEVEL=${LOG_LEVEL:-2}


#
# 終了コード
#
EXIT_SUCCESS=0                    # 正常終了
EXIT_FAILURE=1                    # 一般的なエラー
EXIT_NR_ARGS=64                   # 引数不正/Usageエラー(EX_USAGE相当)
EXIT_INV_ARG=65                   # 関数の引数の値が規定外(内部整合性エラー)
EXIT_ASSERT_ERROR=128             # アサーションエラー(内部整合性エラー)
EXIT_ASSERT_NO_REACH=129          # 到達不可能コードに到達(内部整合性エラー)

# ログレベル文字列の正規化
# LOG_LEVELが整数値でない場合, または 0~5 の範囲外の場合はデフォルト値2に設定する
[[ ${LOG_LEVEL} =~ ^[0-9]+$ ]] || LOG_LEVEL=2
if (( LOG_LEVEL < 0 )) || (( LOG_LEVEL > 5 )); then
    LOG_LEVEL=2
fi

#
# アサーション関数
#
# 引数で与えられた条件式を eval で評価し, 偽の場合は
# "[Assert] Assertion error: <条件式文字列> file=<呼び出し元ファイル> line=<呼び出し元の行番号>"を
# ログと標準エラー出力とに出力してexit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
#
# 引数1: 評価される条件式文字列
# 引数2以降: 任意の補足メッセージ (省略可)
#
# 返却値/終了コード:
#   - 条件式が真の場合は0を返す。
#   - 条件式が偽の場合は, exit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
#   - 引数が無い場合は, exit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
# 動作:
#   - 条件式が真の場合は何も出力せず, 0を返す。
#   - 条件式文字列 を eval で評価し, 偽の場合は, 以下のメッセージをログと標準エラー出力とに出力して,
#     exit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
#     "[Assert] Assertion error: <条件式文字列> file=<呼び出し元ファイル> line=<呼び出し元の行番号>"を
#     ログと標準エラー出力とに出力してexit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
#   - 2つ目以降の引数がある場合は, それらを空白で連結したものを補足メッセージとして,
#     "[Assert] Assertion error: <条件式文字列> file=<呼び出し元ファイル> line=<呼び出し元の行番号> msg=<補足メッセージ>"
#     をログと標準エラー出力とに出力してexit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
#   - 引数が無い場合は,
#     "[Assert] Assertion error: <empty expression> file=<呼び出し元ファイル> line=<呼び出し元の行番号>"を
#     ログと標準エラー出力とに出力してexit(${EXIT_ASSERT_ERROR})でスクリプト全体を終了する。
#
# 注意事項:
#   - 引数の条件式文字列は, シングルクォートで囲むことを推奨。
#     例: assert '[ "$x" -gt 0 ]'
#   - 条件式内で変数を使用する場合は, 変数をダブルクォートで囲むことを推奨。
#
# 補足事項:
#   set -e でも if 内評価なので安全に使用可能。
# 例:
#   assert 'test -f /etc/hosts'      # /etc/hosts が存在することをtestコマンドで確認
#   assert '[ "$x" -gt 0 ]'          # 変数xが0より大きいことを確認
#   assert 'my_func_returns_success' # my_func_returns_success関数が成功を返すことを確認
assert() {
    local expr="$1"
    local note="${2:-}"  # 任意の補足メッセージ
    local file="${BASH_SOURCE[1]:-$(basename -- "$0")}"
    local line="${BASH_LINENO[0]:-0}"
    local msg

    # 引数なしは関数の使い方ミス
    if [[ -z "${expr}" ]]; then
        msg="[Assert] Assertion error: <empty expression> file=${file} line=${line}"

        echo "${msg}" >&2
        exit ${EXIT_ASSERT_ERROR}
    fi

    # 条件評価
    if ! eval -- "${expr}"; then
        msg="[Assert] Assertion error: ${expr} file=${file} line=${line}"

        # 引数2以降を空白連結して補足メッセージとする
        if (( $# >= 2 )); then

            note="${*:2}"
            msg="${msg} msg=${note}"
        fi

        echo "${msg}" >&2
        exit ${EXIT_ASSERT_ERROR}
    fi
    return 0
}

#
# 到達不可能コード到達関数
#
# 終了コード:
#   exit(${EXIT_ASSERT_NO_REACH})でスクリプト全体を終了する。
# 動作:
#   - "[Assert] Reached unreachable code: file=<呼び出し元ファイル> line=<呼び出し元の行番号>"
#     をログと標準エラー出力とに出力してexit(${EXIT_ASSERT_NO_REACH})でスクリプト全体を終了する。
# 例:
#   assert_no_reach
assert_no_reach() {
    local file="${BASH_SOURCE[1]:-$(basename -- "$0")}"
    local line="${BASH_LINENO[0]:-0}"
    local msg="[Assert] Reached unreachable code: file=${file} line=${line}"

    echo "${msg}" >&2
    exit ${EXIT_ASSERT_NO_REACH}
}

#
# ログ出力関数
#
#
# 引数1: ログレベル文字列
#
#   "dbg": Debug
#   "inf": Info
#   "war": Warning
#   "err": Error
#
#   それ以外の文字列を指定した場合は無視される
#
# 引数2: ログメッセージ
# 例:
#   write_log "inf" "This is an info message"
#   write_log "err" "This is an error message"
#
write_log() {
    local prefix

    if [ "$#" -ne 2 ]; then
        echo "[Error] Invalid argument: write_log <level> <message> args=$*" >&2;
        exit ${EXIT_NR_ARGS}
    fi

    case "$1" in
        "dbg")
            (( "${LOG_LEVEL}" > 4 )) || return 0
            prefix="[Debug]"
            ;;
        "inf")
            (( "${LOG_LEVEL}" > 3 )) || return 0
            prefix="[Info]"
            ;;
        "war")
            (( "${LOG_LEVEL}" > 2 )) || return 0
            prefix="[Warning]"
            ;;
        "err")
            (( "${LOG_LEVEL}" > 1 )) || return 0
            prefix="[Error]"
            ;;
        *)
            return 0 # 無視
            ;;
    esac

    echo "${prefix} $2" >&2;

    return 0
}

#
# デバッグログ出力関数
#
# 第1引数: ログメッセージ
#
dbg_log() {

    write_log "dbg" "$*"
    return 0
}

#
# 情報ログ出力関数
#
# 第1引数: ログメッセージ
#
inf_log() {

    write_log "inf" "$*"
    return 0
}

#
# 警告ログ出力関数
#
# 第1引数: ログメッセージ
#
war_log() {

    write_log "war" "$*"
    return 0
}

#
# エラーログ出力関数
#
# 第1引数: ログメッセージ
#
err_log() {

    write_log "err" "$*"
    return 0
}

show_kubeconfig(){
    local in_file
    local label
    local ctx
    local cluster
    local user
    local server
    local ca_data
    local ca_file
    local ca_len
    local tmp

    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        err_log "show_kubeconfig <input-file-path> [label] (args=$*)"
        exit ${EXIT_NR_ARGS}
    fi
    in_file="$1"
    label="${2:-}"

    if [ ! -f "${in_file}" ]; then
        err_log "Cannot open file: ${in_file}"
        exit ${EXIT_INV_ARG}
    fi

    # 環境の KUBECONFIG を無効化し, そのファイル単体を --raw/--flatten で評価
    _kc(){ env -u KUBECONFIG kubectl --kubeconfig="${in_file}" "$@"; }

    # 概要ヘッダ ( ファイルフィンガープリント付き )
    inf_log "===== kubeconfig summary ${label:+(${label})} ====="
    inf_log "file-path: ${in_file}"
    if command -v sha256sum >/dev/null 2>&1; then
        inf_log "sha256: $(sha256sum "${in_file}" | awk '{print $1}')"
    fi

    # current-context が無い場合は contexts[0] を採用
    ctx="$(_kc config view --raw --flatten -o jsonpath='{.current-context}' 2>/dev/null || true)"
    if [ -z "${ctx}" ]; then
        ctx="$(_kc config get-contexts -o name 2>/dev/null | head -n1 || true)"
    fi

    # 主要一覧
    inf_log "contexts: $(_kc config get-contexts -o name 2>/dev/null | tr '\n' ' ' | sed 's/[[:space:]]*$//')"
    inf_log "clusters: $(_kc config get-clusters 2>/dev/null   | tr '\n' ' ' | sed 's/[[:space:]]*$//')"
    inf_log "users:    $(_kc config get-users 2>/dev/null      | tr '\n' ' ' | sed 's/[[:space:]]*$//')"

    # 現用の context -> cluster / user
    cluster="$(_kc config view --raw --flatten \
        -o jsonpath='{.contexts[?(@.name=="'"${ctx}"'")].context.cluster}')"
    user="$(_kc config view --raw --flatten \
        -o jsonpath='{.contexts[?(@.name=="'"${ctx}"'")].context.user}')"

    server="$(_kc config view --raw --flatten \
        -o jsonpath='{.clusters[?(@.name=="'"${cluster}"'")].cluster.server}')"
    ca_data="$(_kc config view --raw --flatten \
        -o jsonpath='{.clusters[?(@.name=="'"${cluster}"'")].cluster.certificate-authority-data}')"
    ca_file="$(_kc config view --raw --flatten \
        -o jsonpath='{.clusters[?(@.name=="'"${cluster}"'")].cluster.certificate-authority}')"
    ca_len=$(expr length "$ca_data")

    inf_log "current-context: ${ctx:-<none>}"
    inf_log "context.cluster: ${cluster:-<none>}"
    inf_log "context.user:    ${user:-<none>}"
    inf_log "cluster.server:  ${server:-<none>}"

    # CA の状態表示 ( DATA+OMITTED 検知も実施 )
    if [ -n "${ca_data}" ]; then
        if [[ "${ca_data}" == *"DATA+OMITTED"* ]] || [[ "${ca_data}" == *"REDACTED"* ]]; then
            war_log "certificate-authority-data is masked (DATA+OMITTED / REDACTED)"
        fi
        inf_log "cluster.certificate-authority-data: present (len=${ca_len}, head='${ca_data:0:16}...')"
    elif [ -n "${ca_file}" ]; then
        if [ -f "${ca_file}" ]; then
            inf_log "cluster.certificate-authority: file='${ca_file}' (exists)"
        else
            war_log "cluster.certificate-authority: file='${ca_file}' (NOT found)"
        fi
    else
        war_log "No CA found (neither data nor file)"
    fi

    # 先頭数行に DATA+OMITTED が含まれるか直接チェック (視覚確認用)
    if grep -m1 -E 'DATA\+OMITTED|REDACTED' "${in_file}" >/dev/null 2>&1; then
        war_log "raw file contains masked fields (saved without --raw?)"
    fi

    inf_log "===== end of summary ${label:+(${label})} ====="
}

create_kubeconfig(){
    local outpath
    local ctx
    local old_cluster
    local new_cluster_name
    local user
    local server
    local ca_data
    local tmp

    if [ "$#" -ne 2 ]; then
        err_log "create_kubeconfig <outfile-path> <new-cluster-name> (args=$*)"
        exit ${EXIT_NR_ARGS}
    fi

    outpath="$1"
    new_cluster_name="$2"

    # ホスト上のadmin.confを保存する
    sudo kubectl --kubeconfig="${KUBE_ADMIN_CONF}" \
	 config view --raw --flatten \
	| tee "${outpath}" >/dev/null


    # 現在の設定値を表示
    inf_log "=== old configuration ==="
    show_kubeconfig "${outpath}"

    # 現在のkubeconfigの設定値を取得
    ctx=$(kubectl --kubeconfig="${outpath}" config view --raw --flatten -o jsonpath='{.current-context}')
    old_cluster=$(kubectl --kubeconfig="${outpath}" \
			  config view \
			  -o jsonpath='{.contexts[?(@.name=="'"${ctx}"'")].context.cluster}')
    user=$(kubectl --kubeconfig="${outpath}" \
		   config view --raw --flatten \
		   -o jsonpath='{.contexts[?(@.name=="'"${ctx}"'")].context.user}')
    server=$(kubectl --kubeconfig="${outpath}" \
		     config view --raw --flatten \
		     -o jsonpath='{.clusters[?(@.name=="'"${old_cluster}"'")].cluster.server}')
    ca_data=$(kubectl --kubeconfig="${outpath}" \
		      config view --raw --flatten \
		      -o jsonpath='{.clusters[?(@.name=="'"${old_cluster}"'")].cluster.certificate-authority-data}')

    # CA を一時展開して新 cluster を作成（data が無ければ file、どちらも無ければ skip-verify）
    tmp=$(mktemp -d)
    ca_file_path=$(kubectl --kubeconfig="${outpath}" \
        config view --raw --flatten -o jsonpath='{.clusters[?(@.name=="'"${old_cluster}"'")].cluster.certificate-authority}')
    set -e
    if [ -n "${ca_data}" ]; then
        echo "${ca_data}" | base64 -d > "${tmp}/ca.crt"
        kubectl --kubeconfig="${outpath}" \
            config set-cluster "${new_cluster_name}" \
            --server="${server}" --certificate-authority="${tmp}/ca.crt" \
            --embed-certs=true
    elif [ -n "${ca_file_path}" ] && [ -f "${ca_file_path}" ]; then
        kubectl --kubeconfig="${outpath}" \
            config set-cluster "${new_cluster_name}" \
            --server="${server}" --certificate-authority="${ca_file_path}" \
            --embed-certs=true
    else
        war_log "No CA found; falling back to --insecure-skip-tls-verify"
        kubectl --kubeconfig="${outpath}" \
            config set-cluster "${new_cluster_name}" \
            --server="${server}" --insecure-skip-tls-verify=true
    fi

    #  新しい cluster を context に反映 (ここが無いと古い cluster を参照したままになる)
    kubectl --kubeconfig="${outpath}" \
        config set-context "${ctx}" --cluster="${new_cluster_name}" --user="${user}"
    kubectl --kubeconfig="${outpath}" \
        config use-context "${ctx}"

    inf_log "=== new configuration (on ${outpath}) ==="
    show_kubeconfig "${outpath}"

    if [ -d "${tmp}" ]; then
	rm -fr "${tmp}"
    fi
}

main(){
    local outfile

    # クラスタ名未指定
    if [[ "${CLUSTER_NAME}" == "none" || -z "${CLUSTER_NAME}" ]]; then
        err_log "No cluster name specified, exit."
	exit ${EXIT_INV_ARG}

    fi

    # 出力ディレクトリ未定義時は, カレントディレクトリを使用
    if [[ "${OUTPUT_DIR}" == "none" || -z "${OUTPUT_DIR}" ]]; then
	OUTPUT_DIR=`pwd`
    fi

    # 出力先ディレクトリがない場合は, 出力先ディレクトリを作成する
    if [[ ! -d "${OUTPUT_DIR}" ]]; then
	mkdir -p "${OUTPUT_DIR}"
    fi

    if [[ ! -d "${OUTPUT_DIR}" ]]; then

	# 出力先ディレクトリがない場合は, エラー終了
        err_log "Cannot create output directory: ${OUTPUT_DIR}"
	exit ${EXIT_INV_ARG}
    fi

    outfile="${OUTPUT_DIR}/${FILE_NAME_PREFIX}${CLUSTER_NAME}${FILE_NAME_POSTFIX}"
    create_kubeconfig "${outfile}" "${CLUSTER_NAME}"
}

main "$@"
