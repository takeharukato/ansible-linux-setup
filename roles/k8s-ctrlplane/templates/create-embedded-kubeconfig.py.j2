#!/usr/bin/env python3
# -*- mode: python; coding: utf-8; line-endings: unix -*-
# SPDX-License-Identifier: BSD-2-Clause
#
# This file is distributed under the two-clause BSD license.
# このファイルは2条項BSDライセンスの下で配布されています。
#
# BSD 2-Clause License
#
# Copyright (c) 2025, TAKEHARU KATO
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# OpenAI's ChatGPT partially generated this code.
# Author has modified some parts.
# OpenAIのChatGPTがこのコードの一部を生成しました。
# 著者が修正している部分があります。

# This file is generated by ansible.
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}

"""admin.confから証明書を埋め込んだkubeconfigを生成するツールです。

Cilium Cluster Mesh で利用可能な kubeconfig を, `kubectl` を介して生成します。
`admin.conf` へのアクセスに sudo が必要な場合のみ, 自動的に sudo を付与します。
共通CA証明書を `--shared-ca` で指定すると, その証明書を最優先で埋め込みます。
"""

from __future__ import annotations

import argparse
import base64
import binascii
import copy
import gettext
import hashlib
import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, cast

import yaml  # type: ignore[import]

LOGGER = logging.getLogger("create_embedded_kubeconfig")


LOCALE = gettext.translation("kubeconfig-convert-tools", fallback=True)
_ = LOCALE.gettext


DEFAULT_ADMIN_CONF = "/etc/kubernetes/admin.conf"
DEFAULT_FILE_POSTFIX = "-embedded.kubeconfig"

class KubectlError(RuntimeError):
    """``kubectl`` 実行失敗を表す例外です。"""


class KubeconfigError(RuntimeError):
    """kubeconfig 操作失敗を表す例外です。"""

def _resolve_file_prefix(value: Optional[str], cluster_name: str) -> str:
    """ファイルプレフィックスを決定します。

    Args:
        value (str | None): CLI で指定されたプレフィックス。
        cluster_name (str): 出力先に利用するクラスタ名。

    Returns:
        str: 利用するプレフィックス文字列。

    Raises:
        KubeconfigError: 引数 ``cluster_name`` が空の場合。

    Examples:
        >>> _resolve_file_prefix("fixed", "demo")
        'fixed'
        >>> _resolve_file_prefix(None, "demo")
        'demo'
    """

    # CLI引数でプレフィクスが指定されていればそれを優先
    if value is not None:
        return value
    # クラスタ名が空の場合は, エラーログを出力して例外を送出
    if not cluster_name:
        LOGGER.error("Cluster name is required to derive file prefix")
        raise KubeconfigError("cluster name is required for file prefix")
    # クラスタ名をプレフィックスとして利用
    return cluster_name

def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    """コマンドライン引数を解析します。

    Args:
        argv (Iterable[str] | None): 解析対象の引数列。``None`` の場合は ``sys.argv`` を利用します。

    Returns:
        argparse.Namespace: 解析済みの引数インスタンス。

    Examples:
        >>> ns = parse_args(["demo", "--file-prefix", "example"])
        >>> (ns.cluster_name, ns.file_prefix)
        ('demo', 'example')
    """

    parser = argparse.ArgumentParser(
        description=_("Create a kubeconfig that embeds cluster certificates."),
    )

    # 位置引数1: クラスタ名
    parser.add_argument(
        "cluster_name",
        help=_("Cluster name to register in the generated kubeconfig."),
    )

    # オプション引数群

    # -c/--admin-conf admin.confのパスを指定,
    # デフォルトは /etc/kubernetes/admin.conf
    parser.add_argument(
        "-c",
        "--admin-conf",
        dest="admin_conf",
        default=DEFAULT_ADMIN_CONF,
        help=_("Path to admin.conf (default: '%(default)s')."),
    )

    # -o/--output-dir 出力ディレクトリを指定,
    # デフォルトはカレントディレクトリ
    parser.add_argument(
        "-o",
        "--output-dir",
        dest="output_dir",
        default=None,
        help=_("Directory to place the generated kubeconfig (default: current directory)."),
    )

    # -p/--file-prefix 生成するkubeconfigのファイル名プレフィックスを指定,
    # デフォルトはクラスタ名
    parser.add_argument(
        "-p",
        "--file-prefix",
        dest="file_prefix",
        default=None,
        help=_("Filename prefix for the generated kubeconfig (default: cluster name)."),
    )

    # -P/--file-postfix 生成するkubeconfigのファイル名サフィックスを指定,
    # デフォルトは -embedded.kubeconfig
    parser.add_argument(
        "-P",
        "--file-postfix",
        dest="file_postfix",
        default=DEFAULT_FILE_POSTFIX,
        help=_("Filename postfix for the generated kubeconfig (default: '%(default)s'; '.kubeconfig' will be appended if omitted)."),
    )

    # -u/--user contexts.context.user, users.name に設定するユーザ名を指定,
    # デフォルトは None (変更しない)
    parser.add_argument(
        "-u",
        "--user",
        dest="user",
        type=str,
        default=None,
        help=_("User name to set in contexts.context.user and users.name (default: no change)."),
    )

    # -x/--context contexts.name に設定するコンテキスト名を指定,
    # デフォルトは None (変更しない)
    parser.add_argument(
        "-x",
        "--context",
        dest="context",
        type=str,
        default=None,
        help=_("Context name to set in contexts.name (default: no change)."),
    )

    # --shared-ca 共通CA証明書のパスを指定
    # デフォルトは, playbook変数 k8s_embed_kubeconfig_shared_ca_path の値
    # 未定義時は, 空文字列(共通CA証明書を利用しない)
    parser.add_argument(
        "--shared-ca",
        dest="shared_ca",
        default={{ k8s_embed_kubeconfig_shared_ca_path | default('', true) | tojson }},
        help=_("Path to shared CA certificate (default: '%(default)s')."),
    )

    # -v/--verbose ログレベルを上げる
    # 繰り返し指定可能
    # デフォルトは0 (WARNING)
    # 1回指定で INFO, 2回以上で DEBUG
    # 例: -vv で DEBUG
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help=_("Increase log verbosity (repeat for more detail)."),
    )

    parsed: Optional[Sequence[str]]
    if argv is None:
        parsed = None
    else:
        parsed = list(argv)

    return parser.parse_args(parsed)


def setup_logging(verbosity: int) -> None:
    """ログレベルを ``-v`` の回数に応じて設定します。

    Args:
        verbosity (int): 指定された ``-v`` の回数。

    Examples:
        >>> setup_logging(0)
        >>> logging.getLogger().level <= logging.WARNING
        True
    """

    # ログレベルを決定
    if verbosity >= 2: # 2回以上の -v 指定(-vv)で DEBUG
        level = logging.DEBUG
    elif verbosity == 1: # 1回の -v 指定(-v)で INFO
        level = logging.INFO
    else: # 指定なしで WARNING
        level = logging.WARNING

    logging.basicConfig(level=level, format="[%(levelname)s] %(message)s")


def _kubectl_env() -> Dict[str, str]:
    """``kubectl`` 実行時に利用する環境変数を生成します。

    Returns:
        Dict[str, str]: ``KUBECONFIG`` を除外した環境変数の写し。

    Examples:
        >>> "KUBECONFIG" in _kubectl_env()
        False
    """

    # 環境変数の写しを生成
    env = os.environ.copy()
    # ``KUBECONFIG`` を除外
    env.pop("KUBECONFIG", None)
    return env


def run_kubectl(
    args: List[str],
    *,
    use_sudo: bool = False,
    check: bool = True,
) -> str:
    """``kubectl`` を実行し標準出力を返します。

    Args:
        args (List[str]): ``kubectl`` に渡す引数列。
        use_sudo (bool): ``sudo`` を付与する場合は ``True``。
        check (bool): 終了コードが 0 以外の場合に例外を送出するかどうか。

    Returns:
        str: ``kubectl`` の標準出力。

    Raises:
        ValueError: 引数が指定されていない場合。
        KubectlError: ``kubectl`` 実行が失敗した場合。

    Examples:
        >>> run_kubectl([])
        Traceback (most recent call last):
        ...
        ValueError: kubectl arguments required
    """

    if not args:
        # 引数が空の場合は例外を送出
        raise ValueError("kubectl arguments required")

    # コマンドラインを構築
    cmd = ["kubectl", *args]

    # sudoが必要な場合は, 先頭にsudoを追加
    if use_sudo:
        cmd.insert(0, "sudo")

    LOGGER.debug("Running command: %s", " ".join(cmd))

    try:
        # kubectl を実行
        completed = subprocess.run(
            cmd,
            check=check,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            env=_kubectl_env(),
        )
    except subprocess.CalledProcessError as exc:  # pragma: no cover - 外部コマンド失敗経路
        stderr = exc.stderr.strip()
        if stderr: # 標準エラー出力があればログに出力
            LOGGER.error("kubectl failed: %s", stderr)
        raise KubectlError("kubectl command failed") from exc

    # 正常終了時は標準出力を返す
    return completed.stdout


def _ensure_dir(path: Path) -> None:
    """出力ディレクトリを作成。

    Args:
        path (Path): 作成または確認するディレクトリ。

    Raises:
        KubeconfigError: ディレクトリの作成に失敗した場合。

    Examples:
        >>> tmp = Path("_doc_tmp_dir")
        >>> _ensure_dir(tmp); tmp.is_dir()
        True
        >>> tmp.rmdir()
    """

    try:
        # ディレクトリを作成(親ディレクトリも含む)
        path.mkdir(parents=True, exist_ok=True)
    except OSError as exc:  # pragma: no cover - OS 依存例外
        # ディレクトリ作成失敗時はエラーログを出力して例外を送出
        LOGGER.error("Cannot create output directory: %s", path)
        raise KubeconfigError("cannot create output directory") from exc


def _load_yaml(text: str) -> Dict[str, Any]:
    """YAML 文字列を辞書に変換します。

    Args:
        text (str): 解析対象の YAML 文字列。

    Returns:
        Dict[str, Any]: YAML から生成された辞書。

    Raises:
        KubeconfigError: YAML の解析に失敗した場合や辞書以外が得られた場合。

    Examples:
        >>> _load_yaml("a: 1") == {"a": 1}
        True
    """

    try:
        # YAML を解析
        data = yaml.safe_load(text)
    except yaml.YAMLError as exc:  # pragma: no cover - YAML解析失敗
        raise KubeconfigError(str(exc)) from exc

    if data is None:
        data = {}
    if not isinstance(data, dict): # 辞書以外が得られた場合は例外を送出
        raise KubeconfigError("Unexpected kubeconfig structure")
    return cast(Dict[str, Any], data)


def _write_yaml(path: Path, data: Dict[str, Any]) -> None:
    """辞書を YAML 形式で書き出します。

    Args:
        path (Path): 書き込み先のファイルパス。
        data (Dict[str, Any]): 書き込む辞書データ。

    Raises:
        OSError: ファイルの書き込みに失敗した場合。

    Examples:
        >>> tmp = Path("_doc_tmp.yaml")
        >>> _write_yaml(tmp, {"a": 1})
        >>> "a:" in tmp.read_text()
        True
        >>> tmp.unlink()
    """

    with path.open("w", encoding="utf-8") as handle:
        # 辞書を YAML 形式で書き出す
        yaml.safe_dump(data, handle, default_flow_style=False, sort_keys=False)


def _file_sha256(path: Path) -> Optional[str]:
    """ファイルの SHA256 ハッシュを計算します。

    Args:
        path (Path): ハッシュを計算するファイル。

    Returns:
        str | None: 正常に読み取れた場合は 16 進文字列, 失敗時は ``None``。

    Examples:
        >>> tmp = Path("_doc_hash.txt")
        >>> _ = tmp.write_text("data")
        >>> _file_sha256(tmp) == hashlib.sha256(b"data").hexdigest()
        True
        >>> tmp.unlink()
    """

    try:
        # ファイルを読み取り SHA256 ハッシュを計算
        with path.open("rb") as handle:
            # SHA256 ハッシュを16進文字列で返す
            digest = hashlib.sha256(handle.read()).hexdigest()
    except OSError:  # pragma: no cover - ファイル読み取り失敗
        return None
    return digest


def _list_names(value: object) -> List[str]:
    """kubeconfig 配列の name フィールドを抽出します。

    Args:
        value (object): ``name`` キーを含む辞書の配列またはその他の値。

    Returns:
        List[str]: 抽出された ``name`` の一覧。

    Examples:
        >>> _list_names([{"name": "a"}, {"name": "b"}])
        ['a', 'b']
    """

    if not isinstance(value, list): # 配列以外の場合は空リストを返す
        return []
    names: List[str] = [] # 抽出結果を格納するリスト

    # 配列内の各要素を処理
    for item in cast(List[object], value):

        if isinstance(item, dict): # 辞書要素の場合のみ処理
            # 辞書要素を取得
            entry = cast(Dict[str, Any], item)
            # name フィールドを取得
            name = entry.get("name")
            if isinstance(name, str): # 文字列の場合のみ追加
                names.append(name)

    return names


def _is_masked_ca(value: str) -> bool:
    """証明書データがマスクされていることを確認する。

    Args:
        value (str): チェック対象の base64 文字列。

    Returns:
        bool: マスク済み文字列なら ``True``。

    Examples:
        >>> _is_masked_ca('DATA+OMITTED....')
        True
    """

    upper = value.upper() # 大文字に変換
    # マスク済み文字列の場合, "DATA+OMITTED" または "REDACTED" が含まれる
    return "DATA+OMITTED" in upper or "REDACTED" in upper


def _dict_entries(value: object) -> List[Dict[str, Any]]:
    """リスト内の辞書要素のみを抽出します。

    Args:
        value (object): 辞書を含む可能性がある値。

    Returns:
        List[Dict[str, Any]]: 辞書として認識された要素の一覧。

    Examples:
        >>> _dict_entries([{"a": 1}, 2])
        [{'a': 1}]
    """

    if not isinstance(value, list): # 配列以外の場合は空リストを返す
        return []
    result: List[Dict[str, Any]] = [] # 抽出結果を格納するリスト

    # 配列内の各要素を処理
    for item in cast(List[object], value):
        if isinstance(item, dict): # 辞書要素の場合のみ追加
            result.append(cast(Dict[str, Any], item)) # 型を明示的にキャスト
    return result # 辞書のリストを返す


def _load_cluster_data(cluster: Dict[str, Any]) -> Dict[str, Any]:
    """クラスタ定義のディープコピーを生成します。

    Args:
        cluster (Dict[str, Any]): クラスタ設定の辞書。

    Returns:
        Dict[str, Any]: ディープコピーされた辞書。

    Examples:
        >>> original = {"name": "demo"}
        >>> copied = _load_cluster_data(original)
        >>> (copied == original, copied is not original)
        (True, True)
    """

    return copy.deepcopy(cluster)


def _read_ca_file(path: Path) -> Optional[str]:
    """CA ファイルを読み取り base64 文字列に変換します。

    Args:
        path (Path): CA ファイルのパス。

    Returns:
        str | None: base64 文字列。読み取りに失敗した場合は ``None``。

    Examples:
        >>> tmp = Path("_doc_ca.crt")
        >>> _ = tmp.write_bytes(b"abc")
        >>> _read_ca_file(tmp) == base64.b64encode(b"abc").decode("ascii")
        True
        >>> tmp.unlink()
    """

    try:
        # ファイルを読み取り, 内容を取得
        with path.open("rb") as handle:
            content = handle.read()
    except FileNotFoundError: # pragma: no cover - ファイル未発見例外
        LOGGER.warning("cluster.certificate-authority: file='%s' (NOT found)", path)
        return None
    except PermissionError: # pragma: no cover - ファイルアクセス権限例外
        LOGGER.warning("cluster.certificate-authority: file='%s' (permission denied)", path)
        return None
    except OSError as exc:  # pragma: no cover - その他OS例外
        LOGGER.warning("cluster.certificate-authority: file='%s' (error: %s)", path, exc)
        return None

    # base64 エンコードして返す
    encoded = base64.b64encode(content).decode("ascii")
    return encoded


def _summarize_masked_fields(path: Path) -> bool:
    """kubeconfig ファイル内にマスク済み文字列が含まれるかを確認します。

    Args:
        path (Path): 対象ファイルのパス。

    Returns:
        bool: マスク済み証明書を示す文字列が含まれていれば ``True``。

    Examples:
        >>> tmp = Path("_doc_masked")
        >>> _ = tmp.write_text("DATA+OMITTED")
        >>> _summarize_masked_fields(tmp)
        True
        >>> tmp.unlink()
    """

    try:
        # ファイルを読み取り, 内容を取得
        text = path.read_text(encoding="utf-8", errors="ignore")
    except OSError: # pragma: no cover - ファイル読み取り失敗
        return False
    # マスク済み文字列が含まれるかを判定して返す
    return _is_masked_ca(text)


def show_kubeconfig(data: Dict[str, Any], path: Path, *, label: Optional[str] = None) -> None:
    """kubeconfig の概要を INFO ログで表示します。

    Args:
        data (Dict[str, Any]): ログ表示対象の kubeconfig データ。
        path (Path): 対応するファイルパス。
        label (str | None): ログに付与するラベル。

    Examples:
        >>> tmp = Path("_doc_show.yaml")
        >>> _write_yaml(tmp, {"contexts": [], "clusters": [], "users": []})
        >>> show_kubeconfig({"contexts": [], "clusters": [], "users": []}, tmp, label="demo")
        >>> tmp.unlink()
    """
    # ラベルが指定されていれば括弧付きで付与
    suffix = f" ({label})" if label else ""
    LOGGER.info("===== kubeconfig summary%s =====", suffix)
    LOGGER.info("file-path: %s", path)

    # ファイルの SHA256 ハッシュを計算
    sha = _file_sha256(path)
    if sha:
        LOGGER.info("sha256: %s", sha)

    # contexts, clusters, users の各エントリを抽出
    contexts_entries = _dict_entries(data.get("contexts"))
    clusters_entries = _dict_entries(data.get("clusters"))
    users_entries = _dict_entries(data.get("users"))

    # 各エントリの name フィールドをログに出力
    LOGGER.info("contexts: %s", " ".join(_list_names(contexts_entries)))
    LOGGER.info("clusters: %s", " ".join(_list_names(clusters_entries)))
    LOGGER.info("users: %s", " ".join(_list_names(users_entries)))

    # current-context を取得
    current_context_value = data.get("current-context")
    # current-context が空文字列または未設定の場合は, 最初の contexts エントリを利用
    current_context = current_context_value if isinstance(current_context_value, str) else ""

    if not current_context and contexts_entries: # pragma: no cover - current-context未設定経路

        # 先頭の contexts エントリの name フィールドを current-context として利用
        name_value = contexts_entries[0].get("name")
        if isinstance(name_value, str):
            current_context = name_value # current-context に設定

    # current-context に対応する contexts エントリを格納する変数
    context_record: Optional[Dict[str, Any]] = None
    # current-context に対応する contexts エントリを検索
    for entry in contexts_entries:
        # name フィールドを取得
        name_value = entry.get("name")
        # current-context と一致する場合は該当エントリを保存してループを抜ける
        if isinstance(name_value, str) and name_value == current_context:
            context_record = entry
            break

    # context_record (current-context) から cluster, user 名を取得
    cluster_name = ""
    user_name = ""
    if context_record: # 有効なcurrent-contextが見つかった場合
        # context フィールドを取得
        context_spec = context_record.get("context")
        if isinstance(context_spec, dict): # context フィールドが辞書であることを確認
            context_spec_dict = cast(Dict[str, Any], context_spec) # 型を明示的にキャスト
            cluster_value = context_spec_dict.get("cluster") # cluster フィールドを取得
            if isinstance(cluster_value, str): # cluster フィールドが文字列であることを確認
                cluster_name = cluster_value # cluster 名を保存
            user_value = context_spec_dict.get("user") # user フィールドを取得
            if isinstance(user_value, str): # user フィールドが文字列であることを確認
                user_name = user_value # user 名を保存

    # clustersエントリを格納する変数
    cluster_record: Optional[Dict[str, Any]] = None
    server = ""
    # cluster_name に対応する clusters エントリを検索
    for entry in clusters_entries:
        name_value = entry.get("name") # name フィールドを取得
        if isinstance(name_value, str) and name_value == cluster_name:
            # cluster_name と一致する場合
            cluster_record = entry # 該当clustersエントリを保存
            cluster_spec = entry.get("cluster") # cluster フィールドを取得
            if isinstance(cluster_spec, dict): # cluster フィールドが辞書であることを確認
                cluster_spec_dict = cast(Dict[str, Any], cluster_spec) # 型を明示的にキャスト
                server_value = cluster_spec_dict.get("server") # server フィールドを取得
                if isinstance(server_value, str):   # server フィールドが文字列であることを確認
                    server = server_value # server URL を保存
            break

    LOGGER.info("current-context: %s", current_context or "<none>")
    LOGGER.info("context.cluster: %s", cluster_name or "<none>")
    LOGGER.info("context.user: %s", user_name or "<none>")
    LOGGER.info("cluster.server: %s", server or "<none>")

    ca_present = False
    ca_len = 0
    ca_head = ""
    ca_file = None
    ca_masked = False

    if cluster_record: # 有効なclustersエントリが見つかった場合
        cluster_spec = cluster_record.get("cluster") # cluster フィールドを取得
        if isinstance(cluster_spec, dict): # cluster フィールドが辞書であることを確認
            cluster_spec_dict = cast(Dict[str, Any], cluster_spec) # 型を明示的にキャスト
            ca_data_value = cluster_spec_dict.get("certificate-authority-data") # certificate-authority-data フィールドを取得
            # certificate-authority-data フィールドが文字列である場合
            if isinstance(ca_data_value, str) and ca_data_value:
                if _is_masked_ca(ca_data_value): # マスク済み文字列の場合
                    LOGGER.warning("certificate-authority-data is masked (DATA+OMITTED / REDACTED)")
                    ca_masked = True
                else:
                    ca_present = True
                    ca_len = len(ca_data_value)
                    ca_head = ca_data_value[:16]
            else: # certificate-authority-data フィールドが存在しない場合
                # certificate-authority フィールドを確認
                ca_file_value = cluster_spec_dict.get("certificate-authority")
                if isinstance(ca_file_value, str) and ca_file_value: # 文字列の場合
                    ca_file = ca_file_value # certificate-authority ファイルパスを保存
                else:
                    LOGGER.warning("No CA found (neither data nor file)")
            if not ca_present and not ca_masked and ca_file: # 有効なCAファイルが指定されている場合
                if Path(ca_file).is_file(): # ファイルが存在する場合
                    LOGGER.info("cluster.certificate-authority: file='%s' (exists)", ca_file)
                else: # ファイルが存在しない場合
                    LOGGER.warning("cluster.certificate-authority: file='%s' (NOT found)", ca_file)

    if ca_present: # certificate-authority-data フィールドが存在する場合
        LOGGER.info(
            "cluster.certificate-authority-data: present (len=%d, head='%s...')",
            ca_len,
            ca_head,
        )

    if _summarize_masked_fields(path): # マスク済みフィールドの要約を表示
        LOGGER.warning("raw file contains masked fields (saved without --raw?)")

    LOGGER.info("===== end of summary%s =====", suffix)


def _select_context(data: Dict[str, Any]) -> tuple[str, Dict[str, Any]]:
    """現在のコンテキストを選択し, その設定を返します。

    Args:
        data (Dict[str, Any]): kubeconfig データ。

    Returns:
        tuple[str, Dict[str, Any]]: (コンテキスト名, コンテキスト設定)。

    Raises:
        KubeconfigError: コンテキストが見つからない場合。

    Examples:
        >>> data = {
        ...     "contexts": [{"name": "c1", "context": {"cluster": "cl", "user": "u"}}],
        ...     "current-context": "c1",
        ... }
        >>> _select_context(data)[0]
        'c1'
    """

    # contexts エントリを取得
    contexts_list = _ensure_list(data, "contexts")
    if not contexts_list: # contexts エントリが空の場合は例外を送出
        raise KubeconfigError("No contexts found in kubeconfig")

    # current-context を取得
    current_context_value = data.get("current-context")
    # current-context が空文字列または未設定の場合は, 最初の contexts エントリを利用
    current_context = current_context_value if isinstance(current_context_value, str) and current_context_value else None
    # contexts エントリから current-context に対応するエントリを検索
    context_record: Optional[Dict[str, Any]] = None
    if current_context: # current-context が有効な場合
        for entry in contexts_list: # contexts エントリをループ
            # name フィールドを取得
            name_value = entry.get("name")
            # current-context と一致する場合は該当エントリを保存してループを抜ける
            if isinstance(name_value, str) and name_value == current_context:
                context_record = entry
                break
    if context_record is None: # current-context が無効または未設定の場合
        # 最初の contexts エントリを current-context として利用
        for entry in contexts_list:
            # name フィールドを取得
            name_value = entry.get("name")
            if isinstance(name_value, str): # name フィールドが文字列の場合
                context_record = entry # 該当エントリを保存
                current_context = name_value # current-context に設定
                # kubeconfig データ内の current-context フィールドも更新
                data["current-context"] = name_value
                break

    if context_record is None: # current-context が無効または未設定の場合は例外を送出
        raise KubeconfigError("Unable to determine current context")

    context_name = context_record.get("name") # コンテキスト名を取得
    if not isinstance(context_name, str) or not context_name: # コンテキスト名が無効な場合は例外を送出
        raise KubeconfigError("Context name is missing")

    context_spec = context_record.get("context") # コンテキスト設定を取得
    if not isinstance(context_spec, dict): # コンテキスト設定が無効な場合は例外を送出
        raise KubeconfigError("Context spec is missing")

    # 型を明示的にキャスト
    context_spec_typed = cast(Dict[str, Any], context_spec)

    # コンテキスト名と設定を返す
    return context_name, context_spec_typed


def _find_cluster(
    data: Dict[str, Any], name: str
) -> tuple[Dict[str, Any], Dict[str, Any]]:
    """クラスタ名に一致するエントリを取得します。

    Args:
        data (Dict[str, Any]): kubeconfig データ。
        name (str): 検索対象のクラスタ名。

    Returns:
        tuple[Dict[str, Any], Dict[str, Any]]: (クラスタエントリ, クラスタ設定)。

    Raises:
        KubeconfigError: 指定したクラスタが存在しない場合。

    Examples:
        >>> data = {
        ...     "clusters": [{"name": "demo", "cluster": {"server": "https://example"}}]
        ... }
        >>> _find_cluster(data, "demo")[1]["server"]
        'https://example'
    """
    # clusters エントリを取得
    clusters_value = _ensure_list(data, "clusters")
    # clusters エントリが空の場合は例外を送出
    if not clusters_value:
        raise KubeconfigError("No clusters defined in kubeconfig")

    # 指定されたクラスタ名に一致するエントリを検索
    for entry in clusters_value:
        # name フィールドを取得
        entry_name = entry.get("name")
        if isinstance(entry_name, str) and entry_name == name: # クラスタ名が一致する場合
            cluster_spec = entry.get("cluster") # cluster フィールドを取得
            if isinstance(cluster_spec, dict): # cluster フィールドが辞書であることを確認
                return entry, cast(Dict[str, Any], cluster_spec) # 型を明示的にキャストして返却
    # 指定されたクラスタ名が見つからない場合は例外を送出
    raise KubeconfigError(f"Cluster '{name}' not found")


def _ensure_list(data: Dict[str, Any], key: str) -> List[Dict[str, Any]]:
    """辞書内の指定キーに辞書リストを確保します。

    Args:
        data (Dict[str, Any]): 変換対象のデータ。
        key (str): 対象となるキー名。

    Returns:
        List[Dict[str, Any]]: フィルタ済みの辞書リスト。

    Examples:
        >>> data = {"clusters": [1, {"name": "demo"}]}
        >>> _ensure_list(data, "clusters")
        [{'name': 'demo'}]
    """

    value = data.get(key) # 指定キーの値を取得
    if isinstance(value, list): # 配列の場合
        filtered: List[Dict[str, Any]] = []
        for item in cast(List[object], value): # 配列内の各要素を処理
            if isinstance(item, dict): # 辞書要素の場合のみ追加
                filtered.append(cast(Dict[str, Any], item))
        data[key] = filtered # 辞書要素のみを格納
        return filtered # フィルタ済みリストを返す
    filtered: List[Dict[str, Any]] = []
    data[key] = filtered # 空リストを格納
    return filtered # 空リストを返す


def _is_valid_embedded_data(value: str) -> bool:
    """埋め込み済み証明書データが有効な base64 かを判定します。

    Args:
        value (str): 確認する base64 文字列。

    Returns:
        bool: 妥当なら ``True``。

    Examples:
        >>> _is_valid_embedded_data(base64.b64encode(b"ok").decode("ascii"))
        True
    """

    if _is_masked_ca(value): # マスク済み文字列の場合は無効
        return False
    try:
        base64.b64decode(value, validate=True) # base64 デコードを試行
    except (binascii.Error, ValueError): # 例外発生時は無効
        return False
    return True # 妥当な base64 文字列

def embed_certificate(
    data: Dict[str, Any],
    new_cluster_name: str,
    *,
    shared_ca_b64: Optional[str] = None,
    shared_ca_path: Optional[Path] = None,
) -> None:
    """既存クラスタから証明書を取り出し, 新しいクラスタへ埋め込みます。

    Args:
        data (Dict[str, Any]): 処理対象の kubeconfig データ。
        new_cluster_name (str): 埋め込み後のクラスタ名。
        shared_ca_b64 (str | None): 共通CAのBase64文字列。
        shared_ca_path (Path | None): 共通CAファイルのパス ( ログ用途 )。

    Raises:
        KubeconfigError: 必須項目が欠落している場合。

    Examples:
        >>> certificate = base64.b64encode(b"ok").decode("ascii")
        >>> data = {
        ...     "contexts": [{"name": "ctx", "context": {"cluster": "old", "user": "user"}}],
        ...     "current-context": "ctx",
        ...     "clusters": [{"name": "old", "cluster": {"server": "https://example", "certificate-authority-data": certificate}}],
        ...     "users": [],
        ... }
        >>> embed_certificate(data, "new")
        >>> any(item["name"] == "new" for item in data["clusters"])
        True
    """
    # 現在のコンテキストを取得
    _drop, context_spec = _select_context(data)
    # 現在のコンテキストからクラスタ名を取得
    old_cluster_name = context_spec.get("cluster")
    # クラスタ名が無効な場合は例外を送出
    if not isinstance(old_cluster_name, str) or not old_cluster_name:
        raise KubeconfigError("Current context does not reference a cluster")

    # 既存クラスタエントリを取得
    _drop, cluster_spec = _find_cluster(data, old_cluster_name)
    # 既存クラスタの server フィールドを確認
    server = cluster_spec.get("server")
    # server フィールドが無効な場合は例外を送出
    if not isinstance(server, str) or not server:
        raise KubeconfigError("Cluster server endpoint is missing")

    # 既存クラスタから証明書情報を取得
    ca_data_value = cluster_spec.get("certificate-authority-data")
    embedded_data: Optional[str] = None
    embedded_source = ""
    if shared_ca_b64: # 共通CAが指定されている場合
        if _is_valid_embedded_data(shared_ca_b64): # 妥当な base64 文字列の場合
            embedded_data = shared_ca_b64 # 埋め込みデータとして設定
            embedded_source = "shared-ca" # 埋め込みソースを設定
            # ログに共通CAの情報を出力
            source_hint = str(shared_ca_path) if shared_ca_path else "<memory>"
            LOGGER.info(
                "Using shared CA certificate from %s (len=%d, head='%s...')",
                source_hint,
                len(shared_ca_b64),
                shared_ca_b64[:16],
            )
        else:
            raise KubeconfigError("shared CA data is invalid base64")
    # 既存クラスタの certificate-authority-data フィールドを確認
    if embedded_data is None and isinstance(ca_data_value, str) and ca_data_value:
        if _is_valid_embedded_data(ca_data_value): # 妥当な base64 文字列の場合
            embedded_data = ca_data_value # certificate-authority-data を埋め込みデータとして設定
            embedded_source = "embedded-data" # 埋め込みソースを設定
        else:
            LOGGER.warning("certificate-authority-data is masked (DATA+OMITTED / REDACTED)")
    # 既存クラスタの certificate-authority フィールドを確認
    ca_file_value = cluster_spec.get("certificate-authority")
    # certificate-authority-data フィールドが無効な場合にのみ処理
    if embedded_data is None and isinstance(ca_file_value, str) and ca_file_value:
        # CA ファイルを読み取り base64 文字列に変換
        embedded_data = _read_ca_file(Path(ca_file_value).expanduser())
        if embedded_data: # 正常に読み取れた場合
            embedded_source = f"file:{ca_file_value}" # 埋め込みソースを設定

    # 新しいクラスタ設定を生成
    new_cluster_spec = _load_cluster_data(cluster_spec)
    if embedded_data: # 埋め込みデータが存在する場合
        # certificate-authority-data フィールドに埋め込みデータを設定
        new_cluster_spec["certificate-authority-data"] = embedded_data
        # 不要なフィールドを削除
        new_cluster_spec.pop("certificate-authority", None)
        new_cluster_spec.pop("insecure-skip-tls-verify", None)
        LOGGER.info("Embedded CA source: %s", embedded_source or "unknown")
    else: # 埋め込みデータが存在しない場合
        # 不要なフィールドを削除
        new_cluster_spec.pop("certificate-authority-data", None)
        new_cluster_spec.pop("certificate-authority", None)
        new_cluster_spec["insecure-skip-tls-verify"] = True
        LOGGER.warning("No CA found; falling back to --insecure-skip-tls-verify")

    # 既存クラスタエントリを削除し, 新しいクラスタエントリを追加
    clusters_list = _ensure_list(data, "clusters")
    # clusters_list[:]とリスト内包表記を使用して, 既存のリストを直接変更
    # 新規作成クラスタ以外のエントリを抽出して再設定
    clusters_list[:] = [item for item in clusters_list if item.get("name") != new_cluster_name]
    # 新規作成クラスタを末尾に追加
    clusters_list.append({"name": new_cluster_name, "cluster": new_cluster_spec})
    # コンテキスト設定のクラスタ名を新しいクラスタ名に更新
    context_spec["cluster"] = new_cluster_name

    LOGGER.info(
        "Updated contexts referencing '%s' to new cluster '%s'", old_cluster_name, new_cluster_name
    )


def needs_sudo(admin_conf: Path) -> bool:
    """admin.conf の読み取りに sudo が必要か判定します。

    Args:
        admin_conf (Path): 対象となる ``admin.conf`` のパス。

    Returns:
        bool: sudo が必要なら ``True``。

    Raises:
        KubeconfigError: ファイルが存在しない, またはアクセスに失敗した場合。

    Examples:
        >>> tmp = Path("_doc_admin.conf")
        >>> _ = tmp.write_text("test")
        >>> needs_sudo(tmp)
        False
        >>> tmp.unlink()
    """

    if not admin_conf.exists(): # ファイルが存在しない場合は例外を送出
        LOGGER.error("Cannot open file: %s", admin_conf)
        raise KubeconfigError("admin.conf not found")

    try: # ファイルの読み取りを試みる
        with admin_conf.open("rb"):
            pass
    except PermissionError: # pragma: no cover - アクセス権限例外
        LOGGER.info("admin.conf requires sudo: %s", admin_conf)
        return True # sudo が必要
    except OSError as exc:  # pragma: no cover - その他IO例外
        LOGGER.error("Cannot open file: %s", admin_conf)
        # KubeconfigError例外を送出
        raise KubeconfigError("failed to access admin.conf") from exc

    return False

def modify_context_name(data: Dict[str, Any], newname: str) -> bool:
    """カレントコンテキストまたは先頭のコンテキストの contexts.name を変更します。
    Args:
        data (Dict[str, Any]): 処理対象の kubeconfig データ。
        newname (str): 新しいコンテキスト名。
    Raises:
        KubeconfigError: 必須項目が欠落している場合。
    returns:
        bool: 正常終了時は True, 失敗時は False。

    Examples:
        >>> data = {
        ...     "contexts": [{"name": "old", "context": {"cluster": "cl", "user": "u"}}],
        ...     "current-context": "old",
        ... }
        >>> modify_context_name(data, "new")
        >>> data["contexts"][0]["name"]
        'new'
    """
    # 現在のコンテキストを取得
    context_name, _drop = _select_context(data)
    # contexts エントリを取得
    contexts_list = _ensure_list(data, "contexts")
    # 指定されたコンテキスト名に一致するエントリを検索
    for entry in contexts_list:
        # name フィールドを取得
        entry_name = entry.get("name")
        if isinstance(entry_name, str) and entry_name == context_name: # コンテキスト名が一致する場合
            entry["name"] = newname # name フィールドを新しい名前に変更
            break

    # kubeconfig データ内の current-context フィールドも更新
    data["current-context"] = newname

    return True

def modify_user_name(data: Dict[str, Any], newname: str) -> bool:
    """旧ユーザ名を参照する全コンテキストのユーザ名, users.nameを変更します。
    Args:
        data (Dict[str, Any]): 処理対象の kubeconfig データ。
        newname (str): 新しいユーザ名。
    Raises:
        KubeconfigError: 必須項目が欠落している場合。
    returns:
        bool: 正常終了時は True, 失敗時は False。
    Examples:
        >>> data = {
        ...     "contexts": [{"name": "ctx", "context": {"cluster": "cl", "user": "old"}}],
        ...     "current-context": "ctx",
        ...     "users": [{"name": "old", "user": {"token": "t"}}],
        ... }
        >>> modify_user_name(data, "new")
        >>> data["users"][0]["name"]
        'new'
    """
    # 現在のコンテキストを取得
    _drop, context_spec = _select_context(data)
    # 現在のコンテキストからユーザ名を取得
    old_user_name = context_spec.get("user")
    # ユーザ名が無効な場合は例外を送出
    if not isinstance(old_user_name, str) or not old_user_name:
        raise KubeconfigError("Current context does not reference a user")

    # 全コンテキストの user を更新
    contexts_list = _ensure_list(data, "contexts") # contexts エントリを取得
    for entry in contexts_list: # contexts エントリ中を検索
        # user フィールドを取得
        context_value = entry.get("context")
        # context フィールドが辞書であることを確認
        if isinstance(context_value, dict):
            # 型を明示的にキャスト
            context_dict = cast(Dict[str, Any], context_value)
            # user フィールドを取得
            user_value: object = context_dict.get("user")
            # user フィールドが文字列であることを確認
            if isinstance(user_value, str) and user_value == old_user_name:
                context_dict["user"] = newname # user フィールドを新しい名前に変更

    # users エントリを更新 (存在しない場合は token/cert をコピーして新規作成)
    users_list = _ensure_list(data, "users")
    # 旧ユーザエントリと新ユーザエントリを検索
    old_entry: Optional[Dict[str, Any]] = None
    new_entry: Optional[Dict[str, Any]] = None
    for entry in users_list: # users エントリ中を検索
        # name フィールドを取得
        entry_name = entry.get("name")
        # name フィールドが文字列であることを確認
        if isinstance(entry_name, str):
            # 旧ユーザエントリが見つかった場合
            if entry_name == old_user_name:
                old_entry = entry # 旧ユーザエントリを保存
            # 新ユーザエントリが見つかった場合
            elif entry_name == newname:
                new_entry = entry # 新ユーザエントリを保存

    # 旧ユーザエントリの user フィールドをテンプレートとして利用
    template_user: Optional[Dict[str, Any]] = None
    if old_entry: # 旧ユーザエントリが存在する場合
        user_value = old_entry.get("user") # user フィールドを取得
        if isinstance(user_value, dict): # user フィールドが辞書であることを確認
            # 旧ユーザエントリの内容をテンプレートとして保存
            template_user = cast(Dict[str, Any], user_value) # 型を明示的にキャスト
    if template_user is None: # 旧ユーザエントリが存在しない場合
        # users エントリ内から最初の user フィールドをテンプレートとして利用
        for entry in users_list:
            user_value = entry.get("user") # user フィールドを取得
            if isinstance(user_value, dict) and user_value: # user フィールドが辞書であることを確認
                # 最初の user フィールドをテンプレートとして利用
                template_user = cast(Dict[str, Any], user_value)
                break

    if old_entry: # 旧ユーザエントリが存在する場合
        # 新ユーザエントリが存在し, 旧ユーザエントリと異なる場合
        if new_entry and new_entry is not old_entry:
            # 新ユーザエントリを削除
            users_list.remove(new_entry)
        # 旧ユーザエントリの name フィールドを新しい名前に変更
        old_entry["name"] = newname
        # 旧ユーザエントリの user フィールドが空の場合, テンプレートをコピー
        if template_user is not None: # template_user が存在する場合
            # テンプレートの内容をディープコピーして設定
            old_entry["user"] = copy.deepcopy(template_user) # 型を明示的にキャスト
    else: # 旧ユーザエントリが存在しない場合
        # 新ユーザエントリが存在しない場合は新規作成
        if new_entry is None:
            # 新規ユーザエントリを追加
            if template_user is None: # テンプレートが存在しない場合は例外を送出
                raise KubeconfigError("No user credentials available to create new user entry")
            # 新規ユーザエントリを追加
            users_list.append({"name": newname, "user": copy.deepcopy(template_user)})
        elif template_user is not None: # 新ユーザエントリが存在する場合
            # 新ユーザエントリの user フィールドが空の場合, テンプレートをコピー
            user_payload = new_entry.get("user")
            # user フィールドが辞書でないか, 空の場合にテンプレートをコピー
            if not isinstance(user_payload, dict) or not user_payload:
                new_entry["user"] = copy.deepcopy(template_user)

    # current-context の user も更新
    context_spec["user"] = newname

    return True

def create_embedded_kubeconfig(args: argparse.Namespace) -> int:
    """メインとなる処理を実行します。

    指定したファイルサフィックスに ``.kubeconfig`` が含まれない場合, 自動的に付与します。

    Args:
        args (argparse.Namespace): コマンドライン引数を格納した名前空間。

    Returns:
        int: 正常終了時は ``0``, 失敗時は ``1``。

    Raises:
        KubeconfigError: 前提条件の確認に失敗した場合。

    Examples:
        >>> ns = argparse.Namespace(
        ...     cluster_name="demo",
        ...     admin_conf="/nonexistent",
        ...     output_dir=None,
        ...     file_prefix="p",
        ...     file_postfix="-s",
        ...     verbose=0,
        ... )
        >>> create_embedded_kubeconfig(ns)
        1
    """

    # クラスタ名を引数から取得
    cluster_name = args.cluster_name
    if not cluster_name:
        # クラスタ名未指定の場合は, エラーログを出力して終了
        LOGGER.error("No cluster name specified, exit.")
        return 1

    # admin.conf パスを解決
    admin_conf = Path(args.admin_conf).expanduser().resolve()
    # 出力ディレクトリを解決
    output_dir = Path(args.output_dir).expanduser().resolve() if args.output_dir else Path.cwd()
    # ファイルプレフィックスを決定
    file_prefix = _resolve_file_prefix(args.file_prefix, cluster_name)
    # ファイルサフィックスを決定
    file_postfix = args.file_postfix or DEFAULT_FILE_POSTFIX

    if not file_postfix.endswith(".kubeconfig"):
        # .kubeconfig が含まれない場合は.kubeconfigを付与
        file_postfix = f"{file_postfix}.kubeconfig"

    # 出力ディレクトリを作成
    _ensure_dir(output_dir)

    # 共通CA証明書を指定されている場合は, 指定された文字列を取得
    shared_ca_argument = str(getattr(args, "shared_ca", "") or "").strip()
    # 共通CA証明書のパスを解決, 指定されていなければ, None
    shared_ca_path = Path(shared_ca_argument).expanduser().resolve() if shared_ca_argument else None
    # 共通CA証明書のBase64文字列を初期化
    shared_ca_b64: Optional[str] = None
    if shared_ca_path:
        # 共通CA証明書のファイルを読み取り, Base64文字列に変換
        try:
            # ファイルをバイナリモードで読み取り
            ca_bytes = shared_ca_path.read_bytes()
        except OSError as exc:
            # ファイルの読み取りに失敗した場合はエラーログを出力して終了
            LOGGER.error("Failed to read shared CA certificate '%s': %s", shared_ca_path, exc)
            return 1
        if not ca_bytes:
            # ファイルが空の場合はエラーログを出力して終了
            LOGGER.error("Shared CA certificate '%s' is empty", shared_ca_path)
            return 1
        # Base64エンコードして文字列に変換
        shared_ca_b64 = base64.b64encode(ca_bytes).decode("ascii")
        LOGGER.info("Loaded shared CA certificate (%d bytes) from %s", len(ca_bytes), shared_ca_path)

    # 出力ファイル名を決定
    filename = f"{file_prefix}{file_postfix}"

    # 出力ファイルのパスを決定
    # pathlib の Path 同士を / 演算子で結合して, ファイルパスを生成
    output_path = output_dir / filename

    # admin.conf の読み取りに sudo が必要か判定
    sudo_required = needs_sudo(admin_conf)

    # kubectl コマンドを実行して, kubeconfig の内容を取得
    stdout = run_kubectl(
        [
            "config",
            "view",
            "--raw",
            "--flatten",
            f"--kubeconfig={admin_conf}",
        ],
        use_sudo=sudo_required,
    )

    # kubectl経由で取得した kubeconfig の内容を YAML 形式で読み込み,
    # pythonの辞書に変換
    data = _load_yaml(stdout)

    # 既存のkubeconfig内容をスナップショットとして保存
    _write_yaml(output_path, data)
    LOGGER.info("Saved kubeconfig snapshot to %s", output_path)

    # 変更前の kubeconfig 概要をログに表示
    show_kubeconfig(data, output_path, label=_("before embed"))

    #
    # 証明書埋め込み処理 ( コンテキスト名, ユーザ名変更より先に実行 )
    #

    try:
        # 証明書を埋め込む処理を実行
        embed_certificate(
            data,
            cluster_name,
            shared_ca_b64=shared_ca_b64,
            shared_ca_path=shared_ca_path,
        )
    except KubeconfigError as exc:
        LOGGER.error(str(exc))
        return 1

    #
    # コンテキスト名とユーザ名の変更処理 ( 証明書埋め込み後に実行 )
    #

    # コンテキスト名の変更処理
    new_context_name = args.context
    if new_context_name and isinstance(new_context_name, str):
        try:
            # コンテキスト名を変更
            modify_context_name(data, new_context_name)
            LOGGER.info("Modified context name to '%s'", new_context_name)
        except KubeconfigError as exc:
            LOGGER.error(str(exc))
            return 1

    # ユーザ名の変更処理
    new_user_name = args.user
    if new_user_name and isinstance(new_user_name, str):
        try:
            # ユーザ名を変更
            modify_user_name(data, new_user_name)
            LOGGER.info("Modified user name to '%s'", new_user_name)
        except KubeconfigError as exc:
            LOGGER.error(str(exc))
            return 1

    # 埋め込み後の kubeconfig をファイルに書き出し
    _write_yaml(output_path, data)
    LOGGER.info("Wrote embedded kubeconfig to %s", output_path)

    # 変更後の kubeconfig 概要をログに表示
    show_kubeconfig(data, output_path, label=_("after embed"))

    return 0


def main(argv: Optional[Iterable[str]] = None) -> int:
    """CLI エントリポイント

    Args:
        argv (Iterable[str] | None): コマンドライン引数。``None`` の場合は ``sys.argv`` を使用します。

    Returns:
        int: プロセス終了コード。

    Examples:
        >>> main(["demo", "--admin-conf", "/nonexistent", "--file-prefix", "p"])
        1
    """

    # コマンドライン引数を解析
    args = parse_args(argv)
    # ロギングを設定
    setup_logging(args.verbose)

    try:
        # メイン処理を実行
        return create_embedded_kubeconfig(args)
    except KubectlError:
        return 1
    except KubeconfigError:
        return 1


if __name__ == "__main__":  # pragma: no cover - CLI エントリポイント
    sys.exit(main())
