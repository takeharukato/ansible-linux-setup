#!/usr/bin/env python3
# -*- mode: python; coding: utf-8; line-endings: unix -*-
# SPDX-License-Identifier: BSD-2-Clause
#
# This file is distributed under the two-clause BSD license.
# このファイルは2条項BSDライセンスの下で配布されています。
#
# BSD 2-Clause License
#
# Copyright (c) 2025, TAKEHARU KATO
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#1. Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# OpenAI's ChatGPT partially generated this code.
# Author has modified some parts.
# OpenAIのChatGPTがこのコードの一部を生成しました。
# 著者が修正している部分があります。

# This file is generated by ansible.
# last update: {{ '%Y-%m-%d %H:%M:%S %Z' | strftime(ansible_date_time.epoch) }}

"""admin.confから証明書を埋め込んだkubeconfigを生成するツールです。

Cilium Cluster Mesh で利用可能な kubeconfig を, `kubectl` を介して生成します。
`admin.conf` へのアクセスに sudo が必要な場合のみ, 自動的に sudo を付与します。
共通CA証明書を `--shared-ca` で指定すると, その証明書を最優先で埋め込みます。
"""

from __future__ import annotations

import argparse
import base64
import binascii
import copy
import gettext
import hashlib
import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, cast

import yaml  # type: ignore[import]

LOGGER = logging.getLogger("create_embedded_kubeconfig")


LOCALE = gettext.translation("kubeconfig-convert-tools", fallback=True)
_ = LOCALE.gettext


DEFAULT_ADMIN_CONF = "/etc/kubernetes/admin.conf"
DEFAULT_FILE_POSTFIX = "-embedded.kubeconfig"


def _resolve_file_prefix(value: Optional[str], cluster_name: str) -> str:
    """ファイルプレフィックスを決定します。

    Args:
        value (str | None): CLI で指定されたプレフィックス。
        cluster_name (str): 出力先に利用するクラスタ名。

    Returns:
        str: 利用するプレフィックス文字列。

    Raises:
        KubeconfigError: 引数 ``cluster_name`` が空の場合。

    Examples:
        >>> _resolve_file_prefix("fixed", "demo")
        'fixed'
        >>> _resolve_file_prefix(None, "demo")
        'demo'
    """

    if value is not None:
        return value
    if not cluster_name:
        LOGGER.error("Cluster name is required to derive file prefix")
        raise KubeconfigError("cluster name is required for file prefix")
    return cluster_name


class KubectlError(RuntimeError):
    """``kubectl`` 実行失敗を表す例外です。"""


class KubeconfigError(RuntimeError):
    """kubeconfig 操作失敗を表す例外です。"""


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    """コマンドライン引数を解析します。

    Args:
        argv (Iterable[str] | None): 解析対象の引数列。``None`` の場合は ``sys.argv`` を利用します。

    Returns:
        argparse.Namespace: 解析済みの引数インスタンス。

    Examples:
        >>> ns = parse_args(["demo", "--file-prefix", "example"])
        >>> (ns.cluster_name, ns.file_prefix)
        ('demo', 'example')
    """

    parser = argparse.ArgumentParser(
        description=_("Create a kubeconfig that embeds cluster certificates."),
    )
    parser.add_argument(
        "cluster_name",
        help=_("Cluster name to register in the generated kubeconfig."),
    )
    parser.add_argument(
        "-c",
        "--admin-conf",
        dest="admin_conf",
        default=DEFAULT_ADMIN_CONF,
        help=_("Path to admin.conf (default: '%(default)s')."),
    )
    parser.add_argument(
        "-o",
        "--output-dir",
        dest="output_dir",
        default=None,
        help=_("Directory to place the generated kubeconfig (default: current directory)."),
    )
    parser.add_argument(
        "-p",
        "--file-prefix",
        dest="file_prefix",
        default=None,
        help=_("Filename prefix for the generated kubeconfig (default: cluster name)."),
    )
    parser.add_argument(
        "-P",
        "--file-postfix",
        dest="file_postfix",
        default=DEFAULT_FILE_POSTFIX,
        help=_("Filename postfix for the generated kubeconfig (default: '%(default)s'; '.kubeconfig' will be appended if omitted)."),
    )
    parser.add_argument(
        "--shared-ca",
        dest="shared_ca",
        default={{ k8s_embed_kubeconfig_shared_ca_path | default('', true) | tojson }},
        help=_("Path to shared CA certificate (default: '%(default)s')."),
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help=_("Increase log verbosity (repeat for more detail)."),
    )

    parsed: Optional[Sequence[str]]
    if argv is None:
        parsed = None
    else:
        parsed = list(argv)

    return parser.parse_args(parsed)


def setup_logging(verbosity: int) -> None:
    """ログレベルを ``-v`` の回数に応じて設定します。

    Args:
        verbosity (int): 指定された ``-v`` の回数。

    Examples:
        >>> setup_logging(0)
        >>> logging.getLogger().level <= logging.WARNING
        True
    """

    if verbosity >= 2:
        level = logging.DEBUG
    elif verbosity == 1:
        level = logging.INFO
    else:
        level = logging.WARNING

    logging.basicConfig(level=level, format="[%(levelname)s] %(message)s")


def _kubectl_env() -> Dict[str, str]:
    """``kubectl`` 実行時に利用する環境変数を生成します。

    Returns:
        Dict[str, str]: ``KUBECONFIG`` を除外した環境変数の写し。

    Examples:
        >>> "KUBECONFIG" in _kubectl_env()
        False
    """

    env = os.environ.copy()
    env.pop("KUBECONFIG", None)
    return env


def run_kubectl(
    args: List[str],
    *,
    use_sudo: bool = False,
    check: bool = True,
) -> str:
    """``kubectl`` を実行し標準出力を返します。

    Args:
        args (List[str]): ``kubectl`` に渡す引数列。
        use_sudo (bool): ``sudo`` を付与する場合は ``True``。
        check (bool): 終了コードが 0 以外の場合に例外を送出するかどうか。

    Returns:
        str: ``kubectl`` の標準出力。

    Raises:
        ValueError: 引数が指定されていない場合。
        KubectlError: ``kubectl`` 実行が失敗した場合。

    Examples:
        >>> run_kubectl([])
        Traceback (most recent call last):
        ...
        ValueError: kubectl arguments required
    """

    if not args:
        raise ValueError("kubectl arguments required")

    cmd = ["kubectl", *args]
    if use_sudo:
        cmd.insert(0, "sudo")

    LOGGER.debug("Running command: %s", " ".join(cmd))

    try:
        completed = subprocess.run(
            cmd,
            check=check,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            env=_kubectl_env(),
        )
    except subprocess.CalledProcessError as exc:  # pragma: no cover - 外部コマンド失敗経路
        stderr = exc.stderr.strip()
        if stderr:
            LOGGER.error("kubectl failed: %s", stderr)
        raise KubectlError("kubectl command failed") from exc

    return completed.stdout


def _ensure_dir(path: Path) -> None:
    """出力ディレクトリを作成します。

    Args:
        path (Path): 作成または確認するディレクトリ。

    Raises:
        KubeconfigError: ディレクトリの作成に失敗した場合。

    Examples:
        >>> tmp = Path("_doc_tmp_dir")
        >>> _ensure_dir(tmp); tmp.is_dir()
        True
        >>> tmp.rmdir()
    """

    try:
        path.mkdir(parents=True, exist_ok=True)
    except OSError as exc:  # pragma: no cover - OS 依存例外
        LOGGER.error("Cannot create output directory: %s", path)
        raise KubeconfigError("cannot create output directory") from exc


def _load_yaml(text: str) -> Dict[str, Any]:
    """YAML 文字列を辞書に変換します。

    Args:
        text (str): 解析対象の YAML 文字列。

    Returns:
        Dict[str, Any]: YAML から生成された辞書。

    Raises:
        KubeconfigError: YAML の解析に失敗した場合や辞書以外が得られた場合。

    Examples:
        >>> _load_yaml("a: 1") == {"a": 1}
        True
    """

    try:
        data = yaml.safe_load(text)
    except yaml.YAMLError as exc:  # pragma: no cover - YAML解析失敗
        raise KubeconfigError(str(exc)) from exc

    if data is None:
        data = {}
    if not isinstance(data, dict):
        raise KubeconfigError("Unexpected kubeconfig structure")
    return cast(Dict[str, Any], data)


def _write_yaml(path: Path, data: Dict[str, Any]) -> None:
    """辞書を YAML 形式で書き出します。

    Args:
        path (Path): 書き込み先のファイルパス。
        data (Dict[str, Any]): 書き込む辞書データ。

    Raises:
        OSError: ファイルの書き込みに失敗した場合。

    Examples:
        >>> tmp = Path("_doc_tmp.yaml")
        >>> _write_yaml(tmp, {"a": 1})
        >>> "a:" in tmp.read_text()
        True
        >>> tmp.unlink()
    """

    with path.open("w", encoding="utf-8") as handle:
        yaml.safe_dump(data, handle, default_flow_style=False, sort_keys=False)


def _file_sha256(path: Path) -> Optional[str]:
    """ファイルの SHA256 ハッシュを計算します。

    Args:
        path (Path): ハッシュを計算するファイル。

    Returns:
        str | None: 正常に読み取れた場合は 16 進文字列, 失敗時は ``None``。

    Examples:
        >>> tmp = Path("_doc_hash.txt")
        >>> _ = tmp.write_text("data")
        >>> _file_sha256(tmp) == hashlib.sha256(b"data").hexdigest()
        True
        >>> tmp.unlink()
    """

    try:
        with path.open("rb") as handle:
            digest = hashlib.sha256(handle.read()).hexdigest()
    except OSError:
        return None
    return digest


def _list_names(value: object) -> List[str]:
    """kubeconfig 配列の name フィールドを抽出します。

    Args:
        value (object): ``name`` キーを含む辞書の配列またはその他の値。

    Returns:
        List[str]: 抽出された ``name`` の一覧。

    Examples:
        >>> _list_names([{"name": "a"}, {"name": "b"}])
        ['a', 'b']
    """

    if not isinstance(value, list):
        return []
    names: List[str] = []
    for item in cast(List[object], value):
        if isinstance(item, dict):
            entry = cast(Dict[str, Any], item)
            name = entry.get("name")
            if isinstance(name, str):
                names.append(name)
    return names


def _is_masked_ca(value: str) -> bool:
    """証明書データがマスクされているかを判定します。

    Args:
        value (str): チェック対象の base64 文字列。

    Returns:
        bool: マスク済み文字列なら ``True``。

    Examples:
        >>> _is_masked_ca('DATA+OMITTED....')
        True
    """

    upper = value.upper()
    return "DATA+OMITTED" in upper or "REDACTED" in upper


def _dict_entries(value: object) -> List[Dict[str, Any]]:
    """リスト内の辞書要素のみを抽出します。

    Args:
        value (object): 辞書を含む可能性がある値。

    Returns:
        List[Dict[str, Any]]: 辞書として認識された要素の一覧。

    Examples:
        >>> _dict_entries([{"a": 1}, 2])
        [{'a': 1}]
    """

    if not isinstance(value, list):
        return []
    result: List[Dict[str, Any]] = []
    for item in cast(List[object], value):
        if isinstance(item, dict):
            result.append(cast(Dict[str, Any], item))
    return result


def _load_cluster_data(cluster: Dict[str, Any]) -> Dict[str, Any]:
    """クラスタ定義のディープコピーを生成します。

    Args:
        cluster (Dict[str, Any]): クラスタ設定の辞書。

    Returns:
        Dict[str, Any]: ディープコピーされた辞書。

    Examples:
        >>> original = {"name": "demo"}
        >>> copied = _load_cluster_data(original)
        >>> (copied == original, copied is not original)
        (True, True)
    """

    return copy.deepcopy(cluster)


def _read_ca_file(path: Path) -> Optional[str]:
    """CA ファイルを読み取り base64 文字列に変換します。

    Args:
        path (Path): CA ファイルのパス。

    Returns:
        str | None: base64 文字列。読み取りに失敗した場合は ``None``。

    Examples:
        >>> tmp = Path("_doc_ca.crt")
        >>> _ = tmp.write_bytes(b"abc")
        >>> _read_ca_file(tmp) == base64.b64encode(b"abc").decode("ascii")
        True
        >>> tmp.unlink()
    """

    try:
        with path.open("rb") as handle:
            content = handle.read()
    except FileNotFoundError:
        LOGGER.warning("cluster.certificate-authority: file='%s' (NOT found)", path)
        return None
    except PermissionError:
        LOGGER.warning("cluster.certificate-authority: file='%s' (permission denied)", path)
        return None
    except OSError as exc:  # pragma: no cover - その他OS例外
        LOGGER.warning("cluster.certificate-authority: file='%s' (error: %s)", path, exc)
        return None

    encoded = base64.b64encode(content).decode("ascii")
    return encoded


def _summarize_masked_fields(path: Path) -> bool:
    """kubeconfig ファイル内にマスク済み文字列が含まれるかを確認します。

    Args:
        path (Path): 対象ファイルのパス。

    Returns:
        bool: マスク済み証明書を示す文字列が含まれていれば ``True``。

    Examples:
        >>> tmp = Path("_doc_masked")
        >>> _ = tmp.write_text("DATA+OMITTED")
        >>> _summarize_masked_fields(tmp)
        True
        >>> tmp.unlink()
    """

    try:
        text = path.read_text(encoding="utf-8", errors="ignore")
    except OSError:
        return False
    upper = text.upper()
    return "DATA+OMITTED" in upper or "REDACTED" in upper


def show_kubeconfig(data: Dict[str, Any], path: Path, *, label: Optional[str] = None) -> None:
    """kubeconfig の概要を INFO ログで表示します。

    Args:
        data (Dict[str, Any]): ログ表示対象の kubeconfig データ。
        path (Path): 対応するファイルパス。
        label (str | None): ログに付与するラベル。

    Examples:
        >>> tmp = Path("_doc_show.yaml")
        >>> _write_yaml(tmp, {"contexts": [], "clusters": [], "users": []})
        >>> show_kubeconfig({"contexts": [], "clusters": [], "users": []}, tmp, label="demo")
        >>> tmp.unlink()
    """

    suffix = f" ({label})" if label else ""
    LOGGER.info("===== kubeconfig summary%s =====", suffix)
    LOGGER.info("file-path: %s", path)

    sha = _file_sha256(path)
    if sha:
        LOGGER.info("sha256: %s", sha)

    contexts_entries = _dict_entries(data.get("contexts"))
    clusters_entries = _dict_entries(data.get("clusters"))
    users_entries = _dict_entries(data.get("users"))

    LOGGER.info("contexts: %s", " ".join(_list_names(contexts_entries)))
    LOGGER.info("clusters: %s", " ".join(_list_names(clusters_entries)))
    LOGGER.info("users: %s", " ".join(_list_names(users_entries)))

    current_context_value = data.get("current-context")
    current_context = current_context_value if isinstance(current_context_value, str) else ""
    if not current_context and contexts_entries:
        name_value = contexts_entries[0].get("name")
        if isinstance(name_value, str):
            current_context = name_value

    context_record: Optional[Dict[str, Any]] = None
    for entry in contexts_entries:
        name_value = entry.get("name")
        if isinstance(name_value, str) and name_value == current_context:
            context_record = entry
            break

    cluster_name = ""
    user_name = ""
    if context_record:
        context_spec = context_record.get("context")
        if isinstance(context_spec, dict):
            context_spec_dict = cast(Dict[str, Any], context_spec)
            cluster_value = context_spec_dict.get("cluster")
            if isinstance(cluster_value, str):
                cluster_name = cluster_value
            user_value = context_spec_dict.get("user")
            if isinstance(user_value, str):
                user_name = user_value

    cluster_record: Optional[Dict[str, Any]] = None
    server = ""
    for entry in clusters_entries:
        name_value = entry.get("name")
        if isinstance(name_value, str) and name_value == cluster_name:
            cluster_record = entry
            cluster_spec = entry.get("cluster")
            if isinstance(cluster_spec, dict):
                cluster_spec_dict = cast(Dict[str, Any], cluster_spec)
                server_value = cluster_spec_dict.get("server")
                if isinstance(server_value, str):
                    server = server_value
            break

    LOGGER.info("current-context: %s", current_context or "<none>")
    LOGGER.info("context.cluster: %s", cluster_name or "<none>")
    LOGGER.info("context.user: %s", user_name or "<none>")
    LOGGER.info("cluster.server: %s", server or "<none>")

    ca_present = False
    ca_len = 0
    ca_head = ""
    ca_file = None
    ca_masked = False

    if cluster_record:
        cluster_spec = cluster_record.get("cluster")
        if isinstance(cluster_spec, dict):
            cluster_spec_dict = cast(Dict[str, Any], cluster_spec)
            ca_data_value = cluster_spec_dict.get("certificate-authority-data")
            if isinstance(ca_data_value, str) and ca_data_value:
                if _is_masked_ca(ca_data_value):
                    LOGGER.warning("certificate-authority-data is masked (DATA+OMITTED / REDACTED)")
                    ca_masked = True
                else:
                    ca_present = True
                    ca_len = len(ca_data_value)
                    ca_head = ca_data_value[:16]
            else:
                ca_file_value = cluster_spec_dict.get("certificate-authority")
                if isinstance(ca_file_value, str) and ca_file_value:
                    ca_file = ca_file_value
                else:
                    LOGGER.warning("No CA found (neither data nor file)")
            if not ca_present and not ca_masked and ca_file:
                if Path(ca_file).is_file():
                    LOGGER.info("cluster.certificate-authority: file='%s' (exists)", ca_file)
                else:
                    LOGGER.warning("cluster.certificate-authority: file='%s' (NOT found)", ca_file)

    if ca_present:
        LOGGER.info(
            "cluster.certificate-authority-data: present (len=%d, head='%s...')",
            ca_len,
            ca_head,
        )

    if _summarize_masked_fields(path):
        LOGGER.warning("raw file contains masked fields (saved without --raw?)")

    LOGGER.info("===== end of summary%s =====", suffix)


def _select_context(data: Dict[str, Any]) -> tuple[str, Dict[str, Any]]:
    """現在のコンテキストを選択し, その設定を返します。

    Args:
        data (Dict[str, Any]): kubeconfig データ。

    Returns:
        tuple[str, Dict[str, Any]]: (コンテキスト名, コンテキスト設定)。

    Raises:
        KubeconfigError: コンテキストが見つからない場合。

    Examples:
        >>> data = {
        ...     "contexts": [{"name": "c1", "context": {"cluster": "cl", "user": "u"}}],
        ...     "current-context": "c1",
        ... }
        >>> _select_context(data)[0]
        'c1'
    """

    contexts_list = _ensure_list(data, "contexts")
    if not contexts_list:
        raise KubeconfigError("No contexts found in kubeconfig")

    current_context_value = data.get("current-context")
    current_context = current_context_value if isinstance(current_context_value, str) and current_context_value else None
    context_record: Optional[Dict[str, Any]] = None
    if current_context:
        for entry in contexts_list:
            name_value = entry.get("name")
            if isinstance(name_value, str) and name_value == current_context:
                context_record = entry
                break
    if context_record is None:
        for entry in contexts_list:
            name_value = entry.get("name")
            if isinstance(name_value, str):
                context_record = entry
                current_context = name_value
                data["current-context"] = name_value
                break

    if context_record is None:
        raise KubeconfigError("Unable to determine current context")

    context_name = context_record.get("name")
    if not isinstance(context_name, str) or not context_name:
        raise KubeconfigError("Context name is missing")

    context_spec = context_record.get("context")
    if not isinstance(context_spec, dict):
        raise KubeconfigError("Context spec is missing")

    context_spec_typed = cast(Dict[str, Any], context_spec)

    return context_name, context_spec_typed


def _find_cluster(
    data: Dict[str, Any], name: str
) -> tuple[Dict[str, Any], Dict[str, Any]]:
    """クラスタ名に一致するエントリを取得します。

    Args:
        data (Dict[str, Any]): kubeconfig データ。
        name (str): 検索対象のクラスタ名。

    Returns:
        tuple[Dict[str, Any], Dict[str, Any]]: (クラスタエントリ, クラスタ設定)。

    Raises:
        KubeconfigError: 指定したクラスタが存在しない場合。

    Examples:
        >>> data = {
        ...     "clusters": [{"name": "demo", "cluster": {"server": "https://example"}}]
        ... }
        >>> _find_cluster(data, "demo")[1]["server"]
        'https://example'
    """

    clusters_value = _ensure_list(data, "clusters")
    if not clusters_value:
        raise KubeconfigError("No clusters defined in kubeconfig")

    for entry in clusters_value:
        entry_name = entry.get("name")
        if isinstance(entry_name, str) and entry_name == name:
            cluster_spec = entry.get("cluster")
            if isinstance(cluster_spec, dict):
                return entry, cast(Dict[str, Any], cluster_spec)
    raise KubeconfigError(f"Cluster '{name}' not found")


def _ensure_list(data: Dict[str, Any], key: str) -> List[Dict[str, Any]]:
    """辞書内の指定キーに辞書リストを確保します。

    Args:
        data (Dict[str, Any]): 変換対象のデータ。
        key (str): 対象となるキー名。

    Returns:
        List[Dict[str, Any]]: フィルタ済みの辞書リスト。

    Examples:
        >>> data = {"clusters": [1, {"name": "demo"}]}
        >>> _ensure_list(data, "clusters")
        [{'name': 'demo'}]
    """

    value = data.get(key)
    if isinstance(value, list):
        filtered: List[Dict[str, Any]] = []
        for item in cast(List[object], value):
            if isinstance(item, dict):
                filtered.append(cast(Dict[str, Any], item))
        data[key] = filtered
        return filtered
    filtered: List[Dict[str, Any]] = []
    data[key] = filtered
    return filtered


def _is_valid_embedded_data(value: str) -> bool:
    """埋め込み済み証明書データが有効な base64 かを判定します。

    Args:
        value (str): 確認する base64 文字列。

    Returns:
        bool: 妥当なら ``True``。

    Examples:
        >>> _is_valid_embedded_data(base64.b64encode(b"ok").decode("ascii"))
        True
    """

    if _is_masked_ca(value):
        return False
    try:
        base64.b64decode(value, validate=True)
    except (binascii.Error, ValueError):
        return False
    return True


def embed_certificate(
    data: Dict[str, Any],
    new_cluster_name: str,
    *,
    shared_ca_b64: Optional[str] = None,
    shared_ca_path: Optional[Path] = None,
) -> None:
    """既存クラスタから証明書を取り出し, 新しいクラスタへ埋め込みます。

    Args:
        data (Dict[str, Any]): 処理対象の kubeconfig データ。
        new_cluster_name (str): 埋め込み後のクラスタ名。
        shared_ca_b64 (str | None): 共通CAのBase64文字列。
        shared_ca_path (Path | None): 共通CAファイルのパス ( ログ用途 )。

    Raises:
        KubeconfigError: 必須項目が欠落している場合。

    Examples:
        >>> certificate = base64.b64encode(b"ok").decode("ascii")
        >>> data = {
        ...     "contexts": [{"name": "ctx", "context": {"cluster": "old", "user": "user"}}],
        ...     "current-context": "ctx",
        ...     "clusters": [{"name": "old", "cluster": {"server": "https://example", "certificate-authority-data": certificate}}],
        ...     "users": [],
        ... }
        >>> embed_certificate(data, "new")
        >>> any(item["name"] == "new" for item in data["clusters"])
        True
    """

    _, context_spec = _select_context(data)
    old_cluster_name = context_spec.get("cluster")
    if not isinstance(old_cluster_name, str) or not old_cluster_name:
        raise KubeconfigError("Current context does not reference a cluster")

    _, cluster_spec = _find_cluster(data, old_cluster_name)
    server = cluster_spec.get("server")
    if not isinstance(server, str) or not server:
        raise KubeconfigError("Cluster server endpoint is missing")

    ca_data_value = cluster_spec.get("certificate-authority-data")
    embedded_data: Optional[str] = None
    embedded_source = ""
    if shared_ca_b64:
        if _is_valid_embedded_data(shared_ca_b64):
            embedded_data = shared_ca_b64
            embedded_source = "shared-ca"
            source_hint = str(shared_ca_path) if shared_ca_path else "<memory>"
            LOGGER.info(
                "Using shared CA certificate from %s (len=%d, head='%s...')",
                source_hint,
                len(shared_ca_b64),
                shared_ca_b64[:16],
            )
        else:
            raise KubeconfigError("shared CA data is invalid base64")
    if embedded_data is None and isinstance(ca_data_value, str) and ca_data_value:
        if _is_valid_embedded_data(ca_data_value):
            embedded_data = ca_data_value
            embedded_source = "embedded-data"
        else:
            LOGGER.warning("certificate-authority-data is masked (DATA+OMITTED / REDACTED)")
    ca_file_value = cluster_spec.get("certificate-authority")
    if embedded_data is None and isinstance(ca_file_value, str) and ca_file_value:
        embedded_data = _read_ca_file(Path(ca_file_value).expanduser())
        if embedded_data:
            embedded_source = f"file:{ca_file_value}"

    new_cluster_spec = _load_cluster_data(cluster_spec)
    if embedded_data:
        new_cluster_spec["certificate-authority-data"] = embedded_data
        new_cluster_spec.pop("certificate-authority", None)
        new_cluster_spec.pop("insecure-skip-tls-verify", None)
        LOGGER.info("Embedded CA source: %s", embedded_source or "unknown")
    else:
        new_cluster_spec.pop("certificate-authority-data", None)
        new_cluster_spec.pop("certificate-authority", None)
        new_cluster_spec["insecure-skip-tls-verify"] = True
        LOGGER.warning("No CA found; falling back to --insecure-skip-tls-verify")

    clusters_list = _ensure_list(data, "clusters")
    clusters_list[:] = [item for item in clusters_list if item.get("name") != new_cluster_name]
    clusters_list.append({"name": new_cluster_name, "cluster": new_cluster_spec})

    context_spec["cluster"] = new_cluster_name

    LOGGER.info(
        "Updated contexts referencing '%s' to new cluster '%s'", old_cluster_name, new_cluster_name
    )


def needs_sudo(admin_conf: Path) -> bool:
    """admin.conf の読み取りに sudo が必要か判定します。

    Args:
        admin_conf (Path): 対象となる ``admin.conf`` のパス。

    Returns:
        bool: sudo が必要なら ``True``。

    Raises:
        KubeconfigError: ファイルが存在しない, またはアクセスに失敗した場合。

    Examples:
        >>> tmp = Path("_doc_admin.conf")
        >>> _ = tmp.write_text("test")
        >>> needs_sudo(tmp)
        False
        >>> tmp.unlink()
    """

    if not admin_conf.exists():
        LOGGER.error("Cannot open file: %s", admin_conf)
        raise KubeconfigError("admin.conf not found")

    try:
        with admin_conf.open("rb"):
            pass
    except PermissionError:
        LOGGER.info("admin.conf requires sudo: %s", admin_conf)
        return True
    except OSError as exc:  # pragma: no cover - その他IO例外
        LOGGER.error("Cannot open file: %s", admin_conf)
        raise KubeconfigError("failed to access admin.conf") from exc

    return False


def create_embedded_kubeconfig(args: argparse.Namespace) -> int:
    """メインとなる処理を実行します。

    指定したファイルサフィックスに ``.kubeconfig`` が含まれない場合, 自動的に付与します。

    Args:
        args (argparse.Namespace): コマンドライン引数を格納した名前空間。

    Returns:
        int: 正常終了時は ``0``, 失敗時は ``1``。

    Raises:
        KubeconfigError: 前提条件の確認に失敗した場合。

    Examples:
        >>> ns = argparse.Namespace(
        ...     cluster_name="demo",
        ...     admin_conf="/nonexistent",
        ...     output_dir=None,
        ...     file_prefix="p",
        ...     file_postfix="-s",
        ...     verbose=0,
        ... )
        >>> create_embedded_kubeconfig(ns)
        1
    """

    cluster_name = args.cluster_name
    if not cluster_name:
        LOGGER.error("No cluster name specified, exit.")
        return 1

    admin_conf = Path(args.admin_conf).expanduser().resolve()
    output_dir = Path(args.output_dir).expanduser().resolve() if args.output_dir else Path.cwd()
    file_prefix = _resolve_file_prefix(args.file_prefix, cluster_name)
    file_postfix = args.file_postfix or DEFAULT_FILE_POSTFIX
    if not file_postfix.endswith(".kubeconfig"):
        file_postfix = f"{file_postfix}.kubeconfig"

    _ensure_dir(output_dir)

    shared_ca_argument = str(getattr(args, "shared_ca", "") or "").strip()
    shared_ca_path = Path(shared_ca_argument).expanduser().resolve() if shared_ca_argument else None
    shared_ca_b64: Optional[str] = None
    if shared_ca_path:
        try:
            ca_bytes = shared_ca_path.read_bytes()
        except OSError as exc:
            LOGGER.error("Failed to read shared CA certificate '%s': %s", shared_ca_path, exc)
            return 1
        if not ca_bytes:
            LOGGER.error("Shared CA certificate '%s' is empty", shared_ca_path)
            return 1
        shared_ca_b64 = base64.b64encode(ca_bytes).decode("ascii")
        LOGGER.info("Loaded shared CA certificate (%d bytes) from %s", len(ca_bytes), shared_ca_path)

    filename = f"{file_prefix}{file_postfix}"

    output_path = output_dir / filename

    sudo_required = needs_sudo(admin_conf)

    stdout = run_kubectl(
        [
            "config",
            "view",
            "--raw",
            "--flatten",
            f"--kubeconfig={admin_conf}",
        ],
        use_sudo=sudo_required,
    )

    data = _load_yaml(stdout)

    _write_yaml(output_path, data)
    LOGGER.info("Saved kubeconfig snapshot to %s", output_path)

    show_kubeconfig(data, output_path, label=_("before embed"))

    try:
        embed_certificate(
            data,
            cluster_name,
            shared_ca_b64=shared_ca_b64,
            shared_ca_path=shared_ca_path,
        )
    except KubeconfigError as exc:
        LOGGER.error(str(exc))
        return 1

    _write_yaml(output_path, data)
    LOGGER.info("Wrote embedded kubeconfig to %s", output_path)

    show_kubeconfig(data, output_path, label=_("after embed"))

    return 0


def main(argv: Optional[Iterable[str]] = None) -> int:
    """CLI エントリポイントです。

    Args:
        argv (Iterable[str] | None): コマンドライン引数。``None`` の場合は ``sys.argv`` を使用します。

    Returns:
        int: プロセス終了コード。

    Examples:
        >>> main(["demo", "--admin-conf", "/nonexistent", "--file-prefix", "p"])
        1
    """

    args = parse_args(argv)
    setup_logging(args.verbose)

    try:
        return create_embedded_kubeconfig(args)
    except KubectlError:
        return 1
    except KubeconfigError:
        return 1


if __name__ == "__main__":  # pragma: no cover - CLI エントリポイント
    sys.exit(main())
